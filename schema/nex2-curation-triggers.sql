-- Generated by Ora2Pg, the Oracle database Schema converter, version 17.4
-- Copyright 2000-2016 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=sgd-nex2-db.stanford.edu;sid=SGD

SET client_encoding TO 'UTF8';

\set ON_ERROR_STOP ON


DROP TRIGGER IF EXISTS authorresponse_audr ON nex.authorresponse CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_authorresponse_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.reference_id != NEW.reference_id) THEN
        PERFORM nex.insertupdatelog('AUTHORRESPONSE'::text, 'REFERENCE_ID'::text, OLD.curation_id, OLD.reference_id::text, NEW.reference_id::text, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('AUTHORRESPONSE'::text, 'SOURCE_ID'::text, OLD.curation_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (((OLD.colleague_id IS NULL) AND (NEW.colleague_id IS NOT NULL)) OR ((OLD.colleague_id IS NOT NULL) AND (NEW.colleague_id IS NULL)) OR (OLD.colleague_id != NEW.colleague_id)) THEN
        PERFORM nex.insertupdatelog('AUTHORRESPONSE'::text, 'COLLEAGUE_ID'::text, OLD.curation_id, OLD.colleague_id::text, NEW.colleague_id::text, USER);
    END IF;

    IF (OLD.author_email != NEW.author_email) THEN
        PERFORM nex.insertupdatelog('AUTHORRESPONSE'::text, 'AUTHOR_EMAIL'::text, OLD.curation_id, OLD.author_email, NEW.author_email, USER);
    END IF;

    IF (OLD.has_novel_research != NEW.has_novel_research) THEN
        PERFORM nex.insertupdatelog('AUTHORRESPONSE'::text, 'HAS_NOVEL_RESEARCH'::text, OLD.curation_id, OLD.has_novel_research::text, NEW.has_novel_research::text, USER);
    END IF;

    IF (OLD.has_large_scale_data != NEW.has_large_scale_data) THEN
        PERFORM nex.insertupdatelog('AUTHORRESPONSE'::text, 'HAS_LARGE_SCALE_DATA'::text, OLD.curation_id, OLD.has_large_scale_data::text, NEW.has_large_scale_data::text, USER);
    END IF;

    IF (OLD.has_fast_track_tag != NEW.has_fast_track_tag) THEN
        PERFORM nex.insertupdatelog('AUTHORRESPONSE'::text, 'HAS_FAST_TRACK_TAG'::text, OLD.curation_id, OLD.has_fast_track_tag::text, NEW.has_fast_track_tag::text, USER);
    END IF;

    IF (OLD.curator_checked_datasets != NEW.curator_checked_datasets) THEN
        PERFORM nex.insertupdatelog('AUTHORRESPONSE'::text, 'CURATOR_CHECKED_DATASETS'::text, OLD.curation_id, OLD.curator_checked_datasets::text, NEW.curator_checked_datasets::text, USER);
    END IF;

    IF (OLD.curator_checked_genelist != NEW.curator_checked_genelist) THEN
        PERFORM nex.insertupdatelog('AUTHORRESPONSE'::text, 'CURATOR_CHECKED_GENELIST'::text, OLD.curation_id, OLD.curator_checked_genelist::text, NEW.curator_checked_genelist::text, USER);
    END IF;

    IF (OLD.no_action_required != NEW.no_action_required) THEN
        PERFORM nex.insertupdatelog('AUTHORRESPONSE'::text, 'NO_ACTION_REQUIRED'::text, OLD.curation_id, OLD.no_action_required::text, NEW.no_action_required::text, USER);
    END IF;

    IF (((OLD.research_results IS NULL) AND (NEW.research_results IS NOT NULL)) OR ((OLD.research_results IS NOT NULL) AND (NEW.research_results IS NULL)) OR (OLD.research_results != NEW.research_results)) THEN
        PERFORM nex.insertupdatelog('AUTHORRESPONSE'::text, 'RESEARCH_RESULTS'::text, OLD.curation_id, OLD.research_results, NEW.research_results, USER);
    END IF;

    IF (((OLD.gene_list IS NULL) AND (NEW.gene_list IS NOT NULL)) OR ((OLD.gene_list IS NOT NULL) AND (NEW.gene_list IS NULL)) OR (OLD.gene_list != NEW.gene_list)) THEN
        PERFORM nex.insertupdatelog('AUTHORRESPONSE'::text, 'GENE_LIST'::text, OLD.curation_id, OLD.gene_list, NEW.gene_list, USER);
    END IF;

    IF (((OLD.dataset_description IS NULL) AND (NEW.dataset_description IS NOT NULL)) OR ((OLD.dataset_description IS NOT NULL) AND (NEW.dataset_description IS NULL)) OR (OLD.dataset_description != NEW.dataset_description)) THEN
        PERFORM nex.insertupdatelog('AUTHORRESPONSE'::text, 'DATASET_DESCRIPTION'::text, OLD.curation_id, OLD.dataset_description, NEW.dataset_description, USER);
    END IF;

    IF (((OLD.other_description IS NULL) AND (NEW.other_description IS NOT NULL)) OR ((OLD.other_description IS NOT NULL) AND (NEW.other_description IS NULL)) OR (OLD.other_description != NEW.other_description)) THEN
        PERFORM nex.insertupdatelog('AUTHORRESPONSE'::text, 'OTHER_DESCRIPTION'::text, OLD.curation_id, OLD.other_description, NEW.other_description, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.curation_id || '[:]' || OLD.reference_id || '[:]' ||
             OLD.source_id || '[:]' || 
             coalesce(OLD.colleague_id,0) || '[:]' || OLD.author_email || '[:]' ||
             OLD.has_novel_research || '[:]' || OLD.has_large_scale_data || '[:]' ||
             OLD.has_fast_track_tag || '[:]' || OLD.curator_checked_datasets || '[:]' ||
             OLD.curator_checked_genelist || '[:]' || OLD.no_action_required || '[:]' ||
             coalesce(OLD.research_results,'') || '[:]' || coalesce(OLD.gene_list,'') || '[:]' ||
             coalesce(OLD.dataset_description,'') || '[:]' || coalesce(OLD.other_description,'') || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

          PERFORM nex.insertdeletelog('AUTHORRESPONSE'::text, OLD.curation_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER authorresponse_audr
AFTER UPDATE OR DELETE ON nex.authorresponse FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_authorresponse_audr();

DROP TRIGGER IF EXISTS authorresponse_biur ON nex.authorresponse CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_authorresponse_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.curation_id != OLD.curation_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER authorresponse_biur
BEFORE INSERT OR UPDATE ON nex.authorresponse FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_authorresponse_biur();


DROP TRIGGER IF EXISTS colleaguetriage_audr ON nex.colleaguetriage CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_colleaguetriage_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.triage_type != NEW.triage_type) THEN
        PERFORM nex.insertupdatelog('COLLEAGUETRIAGE'::text, 'TRIAGE_TYPE'::text, OLD.curation_id, OLD.triage_type, NEW.triage_type, USER);
    END IF;

    IF (((OLD.colleague_id IS NULL) AND (NEW.colleague_id IS NOT NULL)) OR ((OLD.colleague_id IS NOT NULL) AND (NEW.colleague_id IS NULL)) OR (OLD.colleague_id != NEW.colleague_id)) THEN
        PERFORM nex.insertupdatelog('COLLEAGUETRIAGE'::text, 'COLLEAGUE_ID'::text, OLD.curation_id, OLD.colleague_id::text, NEW.colleague_id::text, USER);
    END IF;

    IF (OLD.json != NEW.json) THEN
        PERFORM nex.insertupdatelog('COLLEAGUETRIAGE'::text, 'JSON'::text, OLD.curation_id, OLD.json, NEW.json, USER);
    END IF;

    IF (((OLD.curator_comment IS NULL) AND (NEW.curator_comment IS NOT NULL)) OR ((OLD.curator_comment IS NOT NULL) AND (NEW.curator_comment IS NULL)) OR (OLD.curator_comment != NEW.curator_comment)) THEN
        PERFORM nex.insertupdatelog('COLLEAGUETRIAGE'::text, 'CURATOR_COMMENT'::text, OLD.curation_id, OLD.curator_comment, NEW.curator_comment, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.curation_id || '[:]' || OLD.triage_type || '[:]' ||
             coalesce(OLD.colleague_id,0) || '[:]' || OLD.json || '[:]' ||
	         coalesce(OLD.curator_comment,'') || '[:]' ||
             OLD.date_created;

             PERFORM nex.insertdeletelog('COLLEAGUETRIAGE'::text, OLD.curation_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER colleaguetriage_audr
AFTER UPDATE OR DELETE ON nex.colleaguetriage FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_colleaguetriage_audr();

DROP TRIGGER IF EXISTS colleaguetriage_biur ON nex.colleaguetriage CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_colleaguetriage_biur() RETURNS trigger AS $BODY$
BEGIN

    IF (NEW.curation_id != OLD.curation_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER colleaguetriage_biur
BEFORE UPDATE ON nex.colleaguetriage FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_colleaguetriage_biur();


DROP TRIGGER IF EXISTS curationlocus_audr ON nex.curation_locus CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_curationlocus_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.locus_id != NEW.locus_id) THEN
        PERFORM nex.insertupdatelog('CURATION_LOCUS'::text, 'LOCUS_ID'::text, OLD.curation_id, OLD.locus_id::text, NEW.locus_id::text, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('CURATION_LOCUS'::text, 'SOURCE_ID'::text, OLD.curation_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (OLD.curation_tag != NEW.curation_tag) THEN
        PERFORM nex.insertupdatelog('CURATION_LOCUS'::text, 'CURATION_TAG'::text, OLD.curation_id, OLD.curation_tag, NEW.curation_tag, USER);
    END IF;

    IF (((OLD.curator_comment IS NULL) AND (NEW.curator_comment IS NOT NULL)) OR ((OLD.curator_comment IS NOT NULL) AND (NEW.curator_comment IS NULL)) OR (OLD.curator_comment != NEW.curator_comment)) THEN
        PERFORM nex.insertupdatelog('CURATION_LOCUS'::text, 'CURATOR_COMMENT'::text, OLD.curation_id, OLD.curator_comment, NEW.curator_comment, USER);
    END IF;

    IF (((OLD.json IS NULL) AND (NEW.json IS NOT NULL)) OR ((OLD.json IS NOT NULL) AND (NEW.json IS NULL)) OR (OLD.json != NEW.json)) THEN
        PERFORM nex.insertupdatelog('CURATION_LOCUS'::text, 'JSON'::text, OLD.curation_id, OLD.json, NEW.json, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.curation_id || '[:]' || OLD.locus_id || '[:]' ||
             OLD.source_id || '[:]' || OLD.curation_tag || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by  || '[:]' ||
             coalesce(OLD.curator_comment,'') || '[:]' || coalesce(OLD.json,'');

          PERFORM nex.insertdeletelog('CURATION_LOCUS'::text, OLD.curation_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER curationlocus_audr
AFTER UPDATE OR DELETE ON nex.curation_locus FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_curationlocus_audr();

DROP TRIGGER IF EXISTS curationlocus_biur ON nex.curation_locus CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_curationlocus_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

     NEW.created_by := UPPER(NEW.created_by);
          PERFORM nex.checkuser(NEW.created_by);

     RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.curation_id != OLD.curation_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER curationlocus_biur
BEFORE INSERT OR UPDATE ON nex.curation_locus FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_curationlocus_biur();


DROP TRIGGER IF EXISTS curationreference_audr ON nex.curation_reference CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_curationreference_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.reference_id != NEW.reference_id) THEN
        PERFORM nex.insertupdatelog('CURATION_REFERENCE'::text, 'REFERENCE_ID'::text, OLD.curation_id, OLD.reference_id::text, NEW.reference_id::text, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('CURATION_REFERENCE'::text, 'SOURCE_ID'::text, OLD.curation_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (((OLD.locus_id IS NULL) AND (NEW.locus_id IS NOT NULL)) OR ((OLD.locus_id IS NOT NULL) AND (NEW.locus_id IS NULL)) OR (OLD.locus_id != NEW.locus_id)) THEN
        PERFORM nex.insertupdatelog('CURATION_REFERENCE'::text, 'LOCUS_ID'::text, OLD.curation_id, OLD.locus_id::text, NEW.locus_id::text, USER);
    END IF;

    IF (OLD.curation_tag != NEW.curation_tag) THEN
        PERFORM nex.insertupdatelog('CURATION_REFERENCE'::text, 'CURATION_TAG'::text, OLD.curation_id, OLD.curation_tag, NEW.curation_tag, USER);
    END IF;

    IF (((OLD.curator_comment IS NULL) AND (NEW.curator_comment IS NOT NULL)) OR ((OLD.curator_comment IS NOT NULL) AND (NEW.curator_comment IS NULL)) OR (OLD.curator_comment != NEW.curator_comment)) THEN
        PERFORM nex.insertupdatelog('CURATION_REFERENCE'::text, 'CURATOR_COMMENT'::text, OLD.curation_id, OLD.curator_comment, NEW.curator_comment, USER);
    END IF;

    IF (((OLD.json IS NULL) AND (NEW.json IS NOT NULL)) OR ((OLD.json IS NOT NULL) AND (NEW.json IS NULL)) OR (OLD.json != NEW.json)) THEN
        PERFORM nex.insertupdatelog('CURATION_REFERENCE'::text, 'JSON'::text, OLD.curation_id, OLD.json, NEW.json, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.curation_id || '[:]' || OLD.reference_id || '[:]' ||
             OLD.source_id || '[:]' || coalesce(OLD.locus_id,0) || '[:]' ||
             OLD.curation_tag || '[:]' || OLD.date_created || '[:]' || 
             OLD.created_by  || '[:]' || coalesce(OLD.curator_comment,'') || '[:]' ||
             coalesce(OLD.json,'');

          PERFORM nex.insertdeletelog('CURATION_REFERENCE'::text, OLD.curation_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER curationreference_audr
AFTER UPDATE OR DELETE ON nex.curation_reference FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_curationreference_audr();

DROP TRIGGER IF EXISTS curationreference_biur ON nex.curation_reference CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_curationreference_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

     NEW.created_by := UPPER(NEW.created_by);
          PERFORM nex.checkuser(NEW.created_by);

     RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.curation_id != OLD.curation_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER curationreference_biur
BEFORE INSERT OR UPDATE ON nex.curation_reference FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_curationreference_biur();


DROP TRIGGER IF EXISTS referencetriage_audr ON nex.referencetriage CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_referencetriage_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.pmid != NEW.pmid) THEN
        PERFORM nex.insertupdatelog('REFERENCETRIAGE'::text, 'PMID'::text, OLD.curation_id, OLD.pmid::text, NEW.pmid::text, USER);
    END IF;

     IF (OLD.citation != NEW.citation) THEN
        PERFORM nex.insertupdatelog('REFERENCETRIAGE'::text, 'CITATION'::text, OLD.curation_id, OLD.citation, NEW.citation, USER);
    END IF;

    IF (((OLD.fulltext_url IS NULL) AND (NEW.fulltext_url IS NOT NULL)) OR ((OLD.fulltext_url IS NOT NULL) AND (NEW.fulltext_url IS NULL)) OR (OLD.fulltext_url != NEW.fulltext_url)) THEN
        PERFORM nex.insertupdatelog('REFERENCETRIAGE'::text, 'FULLTEXT_URL'::text, OLD.curation_id, OLD.fulltext_url, NEW.fulltext_url, USER);
    END IF;

    IF (((OLD.abstract_genes IS NULL) AND (NEW.abstract_genes IS NOT NULL)) OR ((OLD.abstract_genes IS NOT NULL) AND (NEW.abstract_genes IS NULL)) OR (OLD.abstract_genes != NEW.abstract_genes)) THEN
        PERFORM nex.insertupdatelog('REFERENCETRIAGE'::text, 'ABSTRACT_GENES'::text, OLD.curation_id, OLD.abstract_genes, NEW.abstract_genes, USER);
    END IF;

    IF (((OLD.abstract IS NULL) AND (NEW.abstract IS NOT NULL)) OR ((OLD.abstract IS NOT NULL) AND (NEW.abstract IS NULL)) OR (OLD.abstract != NEW.abstract)) THEN
        PERFORM nex.insertupdatelog('REFERENCETRIAGE'::text, 'ABSTRACT'::text, OLD.curation_id, OLD.abstract, NEW.abstract, USER);
    END IF;

    IF (((OLD.json IS NULL) AND (NEW.json IS NOT NULL)) OR ((OLD.json IS NOT NULL) AND (NEW.json IS NULL)) OR (OLD.json != NEW.json)) THEN
        PERFORM nex.insertupdatelog('REFERENCETRIAGE'::text, 'JSON'::text, OLD.curation_id, OLD.json, NEW.json, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.curation_id || '[:]' || OLD.pmid || '[:]' ||
             OLD.citation || '[:]' || coalesce(OLD.fulltext_url,'') || '[:]' ||
             coalesce(OLD.abstract_genes,'') || '[:]' ||
             coalesce(OLD.abstract,'') || '[:]' || coalesce(OLD.json,'') || '[:]' ||
             OLD.date_created;

           PERFORM nex.insertdeletelog('REFERENCETRIAGE'::text, OLD.curation_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER referencetriage_audr
AFTER UPDATE OR DELETE ON nex.referencetriage FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_referencetriage_audr();

DROP TRIGGER IF EXISTS referencetriage_biur ON nex.referencetriage CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_referencetriage_biur() RETURNS trigger AS $BODY$
BEGIN

    IF (NEW.curation_id != OLD.curation_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER referencetriage_biur
BEFORE UPDATE ON nex.referencetriage FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_referencetriage_biur();

DROP TRIGGER IF EXISTS reservednametriage_audr ON nex.reservednametriage CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_reservednametriage_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.proposed_gene_name != NEW.proposed_gene_name) THEN
        PERFORM nex.insertupdatelog('RESERVEDNAMETRIAGE'::text, 'PROPOSED_GENE_NAME'::text, OLD.curation_id, OLD.proposed_gene_name::text, NEW.proposed_gene_name::text, USER);
    END IF;

     IF (OLD.colleague_id != NEW.colleague_id) THEN
        PERFORM nex.insertupdatelog('RESERVEDNAMETRIAGE'::text, 'COLLEAGUE_ID'::text, OLD.curation_id, OLD.colleague_id::text, NEW.colleague_id::text, USER);
    END IF;

    IF (OLD.json != NEW.json) THEN
        PERFORM nex.insertupdatelog('RESERVEDNAMETRIAGE'::text, 'JSON'::text, OLD.curation_id, OLD.json, NEW.json, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.curation_id || '[:]' || OLD.proposed_gene_name || '[:]' ||
             OLD.colleague_id || '[:]' || OLD.json || '[:]' ||
             OLD.date_created;

           PERFORM nex.insertdeletelog('RESERVEDNAMETRIAGE'::text, OLD.curation_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER reservednametriage_audr
AFTER UPDATE OR DELETE ON nex.reservednametriage FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_reservednametriage_audr();

DROP TRIGGER IF EXISTS reservednametriage_biur ON nex.reservednametriage CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_reservednametriage_biur() RETURNS trigger AS $BODY$
BEGIN

    IF (NEW.curation_id != OLD.curation_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER reservednametriage_biur
BEFORE UPDATE ON nex.reservednametriage FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_reservednametriage_biur();


DROP TRIGGER IF EXISTS curatoractivity_audr ON nex.curatoractivity CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_curatoractivity_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('CURATORACTIVITY'::text, 'DISPLAY_NAME'::text, OLD.curation_id, OLD.display_name::text, NEW.display_name::text, USER);
    END IF;

     IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('CURATORACTIVITY'::text, 'OBJ_URL'::text, OLD.curation_id, OLD.obj_url::text, NEW.obj_url::text, USER);
    END IF;

     IF (OLD.activity_category != NEW.activity_category) THEN
        PERFORM nex.insertupdatelog('CURATORACTIVITY'::text, 'ACTIVITY_CATEGORY'::text, OLD.curation_id, OLD.activity_category::text, NEW.activity_category::text, USER);
    END IF;

    IF (((OLD.dbentity_id IS NULL) AND (NEW.dbentity_id IS NOT NULL)) OR ((OLD.dbentity_id IS NOT NULL) AND (NEW.dbentity_id IS NULL)) OR (OLD.dbentity_id != NEW.dbentity_id)) THEN
        PERFORM nex.insertupdatelog('COLLEAGUETRIAGE'::text, 'DBENTITY_ID'::text, OLD.curation_id, OLD.dbentity_id::text, NEW.dbentity_id::text, USER);
    END IF;

     IF (OLD.message != NEW.message) THEN
        PERFORM nex.insertupdatelog('CURATORACTIVITY'::text, 'MESSAGE'::text, OLD.curation_id, OLD.message::text, NEW.message::text, USER);
    END IF;

    IF (OLD.json != NEW.json) THEN
        PERFORM nex.insertupdatelog('CURATORACTIVITY'::text, 'JSON'::text, OLD.curation_id, OLD.json, NEW.json, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.curation_id || '[:]' || OLD.display_name || '[:]' ||
             OLD.obj_url || '[:]' || OLD.activity_category || '[:]' ||
             coalesce(OLD.dbentity_id,0) || '[:]' ||
             OLD.message || '[:]' || OLD.json || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

           PERFORM nex.insertdeletelog('CURATORACTIVITY'::text, OLD.curation_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER curatoractivity_audr
AFTER UPDATE OR DELETE ON nex.curatoractivity FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_curatoractivity_audr();

DROP TRIGGER IF EXISTS curatoractivity_biur ON nex.curatoractivity CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_curatoractivity_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.curation_id != OLD.curation_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER curatoractivity_biur
BEFORE INSERT OR UPDATE ON nex.curatoractivity FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_curatoractivity_biur();
