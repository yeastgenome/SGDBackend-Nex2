-- Generated by Ora2Pg, the Oracle database Schema converter, version 17.4
-- Copyright 2000-2016 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=sgd-nex2-db.stanford.edu;sid=SGD

SET client_encoding TO 'UTF8';

\set ON_ERROR_STOP ON


DROP TRIGGER IF EXISTS apo_audr ON nex.apo CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_apo_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.format_name != NEW.format_name) THEN
        PERFORM nex.insertupdatelog('APO'::text, 'FORMAT_NAME'::text, OLD.apo_id, OLD.format_name, NEW.format_name, USER);
    END IF;

    IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('APO'::text, 'DISPLAY_NAME'::text, OLD.apo_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('APO'::text, 'OBJ_URL'::text, OLD.apo_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

    IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('APO'::text, 'SOURCE_ID'::text, OLD.apo_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (OLD.apoid != NEW.apoid) THEN
        PERFORM nex.insertupdatelog('APO'::text, 'APOID'::text, OLD.apo_id, OLD.apoid, NEW.apoid, USER);
    END IF;

    IF (OLD.apo_namespace != NEW.apo_namespace) THEN
        PERFORM nex.insertupdatelog('APO'::text, 'APO_NAMESPACE'::text, OLD.apo_id, OLD.apo_namespace, NEW.apo_namespace, USER);
    END IF;

    IF (((OLD.namespace_group IS NULL) AND (NEW.namespace_group IS NOT NULL)) OR ((OLD.namespace_group IS NOT NULL) AND (NEW.namespace_group IS NULL)) OR (OLD.namespace_group != NEW.namespace_group)) THEN
        PERFORM nex.insertupdatelog('APO'::text, 'NAMESPACE_GROUP'::text, OLD.apo_id, OLD.namespace_group, NEW.namespace_group, USER);
    END IF;

    IF (OLD.is_obsolete != NEW.is_obsolete) THEN
        PERFORM nex.insertupdatelog('APO'::text, 'IS_OBSOLETE'::text, OLD.apo_id, OLD.is_obsolete::text, NEW.is_obsolete::text, USER);
    END IF;

    IF (OLD.is_in_slim != NEW.is_in_slim) THEN
        PERFORM nex.insertupdatelog('APO'::text, 'IS_IN_SLIM'::text, OLD.apo_id, OLD.is_in_slim, NEW.is_in_slim, USER);
    END IF;

    IF (((OLD.description IS NULL) AND (NEW.description IS NOT NULL)) OR ((OLD.description IS NOT NULL) AND (NEW.description IS NULL)) OR (OLD.description != NEW.description)) THEN
        PERFORM nex.insertupdatelog('APO'::text, 'DESCRIPTION'::text, OLD.apo_id, OLD.description, NEW.description, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.apo_id || '[:]' || OLD.format_name || '[:]' ||
             OLD.display_name || '[:]' || OLD.obj_url || '[:]' ||
             OLD.source_id || '[:]' || OLD.apo_id || '[:]' || 
             OLD.apo_namespace || '[:]' || coalesce(OLD.namespace_group,'') || '[:]' || 
             OLD.is_obsolete || '[:]' || OLD.is_in_slim || '[:]' || 
             coalesce(OLD.description,'') || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

    PERFORM nex.insertdeletelog('APO'::text, OLD.apo_id, v_row, USER);

    RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER apo_audr
AFTER UPDATE OR DELETE ON nex.apo FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_apo_audr();

DROP TRIGGER IF EXISTS apo_biur ON nex.apo CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_apo_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.apo_id != OLD.apo_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER apo_biur
BEFORE INSERT OR UPDATE ON nex.apo FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_apo_biur();

DROP TRIGGER IF EXISTS apoalias_audr ON nex.apo_alias CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_apoalias_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

     IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('APO_ALIAS'::text, 'DISPLAY_NAME'::text, OLD.alias_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('APO_ALIAS'::text, 'SOURCE_ID'::text, OLD.alias_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (OLD.apo_id != NEW.apo_id) THEN
        PERFORM nex.insertupdatelog('APO_ALIAS'::text, 'APO_ID'::text, OLD.alias_id, OLD.apo_id::text, NEW.apo_id::text, USER);
    END IF;

    IF (OLD.alias_type != NEW.alias_type) THEN
        PERFORM nex.insertupdatelog('APO_ALIAS'::text, 'ALIAS_TYPE'::text, OLD.alias_id, OLD.alias_type, NEW.alias_type, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.alias_id || '[:]' || OLD.display_name || '[:]' || 
             OLD.source_id || '[:]' || 
             OLD.apo_id || '[:]' || OLD.alias_type || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

    PERFORM nex.insertdeletelog('APO_ALIAS'::text, OLD.alias_id, v_row, USER);

    RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER apoalias_audr
AFTER UPDATE OR DELETE ON nex.apo_alias FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_apoalias_audr();

DROP TRIGGER IF EXISTS apoalias_biur ON nex.apo_alias CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_apoalias_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

   ELSIF (TG_OP = 'UPDATE') THEN

     IF (NEW.alias_id != OLD.alias_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
     END IF;

     IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
     END IF;

     IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
     END IF;

     RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER apoalias_biur
BEFORE INSERT OR UPDATE ON nex.apo_alias FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_apoalias_biur();

DROP TRIGGER IF EXISTS aporelation_audr ON nex.apo_relation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_aporelation_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('APO_RELATION'::text, 'SOURCE_ID'::text, OLD.relation_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

     IF (OLD.parent_id != NEW.parent_id) THEN
        PERFORM nex.insertupdatelog('APO_RELATION'::text, 'PARENT_ID'::text, OLD.relation_id, OLD.parent_id::text, NEW.parent_id::text, USER);
    END IF;

     IF (OLD.child_id != NEW.child_id) THEN
        PERFORM nex.insertupdatelog('APO_RELATION'::text, 'CHILD_ID'::text, OLD.relation_id, OLD.child_id::text, NEW.child_id::text, USER);
    END IF;

    IF (OLD.ro_id != NEW.ro_id) THEN
        PERFORM nex.insertupdatelog('APO_RELATION'::text, 'RO_ID'::text, OLD.relation_id, OLD.ro_id::text, NEW.ro_id::text, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.relation_id || '[:]' || OLD.source_id || '[:]' ||
             OLD.parent_id || '[:]' ||
             OLD.child_id || '[:]' || OLD.ro_id || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

    PERFORM nex.insertdeletelog('APO_RELATION'::text, OLD.relation_id, v_row, USER);

    RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER aporelation_audr
AFTER UPDATE OR DELETE ON nex.apo_relation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_aporelation_audr();

DROP TRIGGER IF EXISTS aporelation_biur ON nex.apo_relation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_aporelation_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.relation_id != OLD.relation_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER aporelation_biur
BEFORE INSERT OR UPDATE ON nex.apo_relation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_aporelation_biur();

DROP TRIGGER IF EXISTS apourl_audr ON nex.apo_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_apourl_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF TG_OP = 'UPDATE' THEN

    IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('APO_URL'::text, 'DISPLAY_NAME'::text, OLD.url_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('APO_URL'::text, 'OBJ_URL'::text, OLD.url_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('APO_URL'::text, 'SOURCE_ID'::text, OLD.url_id, OLD.source_id::text, NEW.source_id::text, USER);
     END IF;

     IF (OLD.apo_id != NEW.apo_id) THEN
        PERFORM nex.insertupdatelog('APO_URL'::text, 'APO_ID'::text, OLD.url_id, OLD.apo_id::text, NEW.apo_id::text, USER);
     END IF;

     IF (OLD.url_type != NEW.url_type) THEN
        PERFORM nex.insertupdatelog('APO_URL'::text, 'URL_TYPE'::text, OLD.url_id, OLD.url_type, NEW.url_type, USER);
     END IF;

     RETURN NEW;
     
  ELSIF (TG_OP = 'DELETE') THEN

     v_row := OLD.url_id || '[:]' ||
              OLD.display_name || '[:]' || OLD.obj_url || '[:]' ||
              OLD.source_id || '[:]' || 
              OLD.apo_id || '[:]' || OLD.url_type || '[:]' ||
              OLD.date_created || '[:]' || OLD.created_by;

              PERFORM nex.insertdeletelog('APO_URL'::text, OLD.url_id, v_row, USER);

      RETURN OLD;
   END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER apourl_audr
AFTER UPDATE OR DELETE ON nex.apo_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_apourl_audr();

DROP TRIGGER IF EXISTS apourl_biur ON nex.apo_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_apourl_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.url_id != OLD.url_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER apourl_biur
BEFORE INSERT OR UPDATE ON nex.apo_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_apourl_biur();


DROP TRIGGER IF EXISTS chebi_audr ON nex.chebi CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_chebi_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.format_name != NEW.format_name) THEN
        PERFORM nex.insertupdatelog('CHEBI'::text, 'FORMAT_NAME'::text, OLD.chebi_id, OLD.format_name, NEW.format_name, USER);
    END IF;

    IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('CHEBI'::text, 'DISPLAY_NAME'::text, OLD.chebi_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('CHEBI'::text, 'OBJ_URL'::text, OLD.chebi_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('CHEBI'::text, 'SOURCE_ID'::text, OLD.chebi_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (OLD.chebiid != NEW.chebiid) THEN
        PERFORM nex.insertupdatelog('CHEBI'::text, 'CHEBIID'::text, OLD.chebi_id, OLD.chebiid, NEW.chebiid, USER);
    END IF;

    IF (OLD.is_obsolete != NEW.is_obsolete) THEN
	PERFORM nex.insertupdatelog('CHEBI'::text, 'IS_OBSOLETE'::text, OLD.chebi_id, OLD.is_obsolete::text, NEW.is_obsolete::text, USER);
    END IF;

    IF (((OLD.description IS NULL) AND (NEW.description IS NOT NULL)) OR ((OLD.description IS NOT NULL) AND (NEW.description IS NULL)) OR (OLD.description != NEW.description)) THEN
        PERFORM nex.insertupdatelog('CHEBI'::text, 'DESCRIPTION'::text, OLD.chebi_id, OLD.description, NEW.description, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.chebi_id || '[:]' || OLD.format_name || '[:]' ||
  	         OLD.display_name || '[:]' || OLD.obj_url || '[:]' ||
             OLD.source_id || '[:]' || OLD.chebiid || '[:]' || 
             OLD.is_obsolete || '[:]' || coalesce(OLD.description,'') || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

    PERFORM nex.insertdeletelog('CHEBI'::text, OLD.chebi_id, v_row, USER);

    RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER chebi_audr
AFTER UPDATE OR DELETE ON nex.chebi FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_chebi_audr();

DROP TRIGGER IF EXISTS chebi_biur ON nex.chebi CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_chebi_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.chebi_id != OLD.chebi_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER chebi_biur
BEFORE INSERT OR UPDATE ON nex.chebi FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_chebi_biur();

DROP TRIGGER IF EXISTS chebialias_audr ON nex.chebi_alias CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_chebialias_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('CHEBI_ALIAS'::text, 'DISPLAY_NAME'::text, OLD.alias_id, OLD.display_name, NEW.display_name, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('CHEBI_ALIAS'::text, 'SOURCE_ID'::text, OLD.alias_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (OLD.chebi_id != NEW.chebi_id) THEN
        PERFORM nex.insertupdatelog('CHEBI_ALIAS'::text, 'CHEBI_ID'::text, OLD.alias_id, OLD.chebi_id::text, NEW.chebi_id::text, USER);
    END IF;

    IF (OLD.alias_type != NEW.alias_type) THEN
        PERFORM nex.insertupdatelog('CHEBI_ALIAS'::text, 'ALIAS_TYPE'::text, OLD.alias_id, OLD.alias_type, NEW.alias_type, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.alias_id || '[:]' || OLD.display_name || '[:]' || 
             OLD.source_id || '[:]' ||
             OLD.chebi_id || '[:]' || OLD.alias_type || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

    PERFORM nex.insertdeletelog('CHEBI_ALIAS'::text, OLD.alias_id, v_row, USER);

    RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER chebialias_audr
AFTER UPDATE OR DELETE ON nex.chebi_alias FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_chebialias_audr();

DROP TRIGGER IF EXISTS chebialias_biur ON nex.chebi_alias CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_chebialias_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.alias_id != OLD.alias_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER chebialias_biur
	BEFORE INSERT OR UPDATE ON nex.chebi_alias FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_chebialias_biur();

DROP TRIGGER IF EXISTS chebiurl_audr ON nex.chebi_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_chebiurl_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('CHEBI_URL'::text, 'DISPLAY_NAME'::text, OLD.url_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('CHEBI_URL'::text, 'OBJ_URL'::text, OLD.url_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('CHEBI_URL'::text, 'SOURCE_ID'::text, OLD.url_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (OLD.chebi_id != NEW.chebi_id) THEN
        PERFORM nex.insertupdatelog('CHEBI_URL'::text, 'CHEBI_ID'::text, OLD.url_id, OLD.chebi_id::text, NEW.chebi_id::text, USER);
    END IF;

    IF (OLD.url_type != NEW.url_type) THEN
        PERFORM nex.insertupdatelog('CHEBI_URL'::text, 'URL_TYPE'::text, OLD.url_id, OLD.url_type, NEW.url_type, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.url_id || '[:]' || OLD.display_name || '[:]' ||
             OLD.obj_url || '[:]' || OLD.source_id || '[:]' || 
             OLD.chebi_id || '[:]' || OLD.url_type || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

    PERFORM nex.insertdeletelog('CHEBI_URL'::text, OLD.url_id, v_row, USER);

    RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER chebiurl_audr
AFTER UPDATE OR DELETE ON nex.chebi_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_chebiurl_audr();

DROP TRIGGER IF EXISTS chebiurl_biur ON nex.chebi_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_chebiurl_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.url_id != OLD.url_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER chebiurl_biur
BEFORE INSERT OR UPDATE ON nex.chebi_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_chebiurl_biur();


DROP TRIGGER IF EXISTS disease_audr ON nex.disease CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_disease_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.format_name != NEW.format_name) THEN
        PERFORM nex.insertupdatelog('DISEASE'::text, 'FORMAT_NAME'::text, OLD.disease_id, OLD.format_name, NEW.format_name, USER);
    END IF;

    IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('DISEASE'::text, 'DISPLAY_NAME'::text, OLD.disease_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('DISEASE'::text, 'OBJ_URL'::text, OLD.disease_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('DISEASE'::text, 'SOURCE_ID'::text, OLD.disease_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (OLD.doid != NEW.doid) THEN
        PERFORM nex.insertupdatelog('DISEASE'::text, 'DOID'::text, OLD.disease_id, OLD.doid, NEW.doid, USER);
    END IF;

    IF (OLD.is_obsolete != NEW.is_obsolete) THEN
	PERFORM nex.insertupdatelog('DISEASE'::text, 'IS_OBSOLETE'::text, OLD.disease_id, OLD.is_obsolete::text, NEW.is_obsolete::text, USER);
    END IF;

    IF (((OLD.description IS NULL) AND (NEW.description IS NOT NULL)) OR ((OLD.description IS NOT NULL) AND (NEW.description IS NULL)) OR (OLD.description != NEW.description)) THEN
        PERFORM nex.insertupdatelog('DISEASE'::text, 'DESCRIPTION'::text, OLD.disease_id, OLD.description, NEW.description, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.disease_id || '[:]' || OLD.format_name || '[:]' ||
             OLD.display_name || '[:]' || OLD.obj_url || '[:]' ||
             OLD.source_id || '[:]' || OLD.doid || '[:]' || 
             OLD.is_obsolete || '[:]' || coalesce(OLD.description,'') || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('DISEASE'::text, OLD.disease_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER disease_audr
AFTER UPDATE OR DELETE ON nex.disease FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_disease_audr();

DROP TRIGGER IF EXISTS disease_biur ON nex.disease CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_disease_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

      NEW.created_by := UPPER(NEW.created_by);
      PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;
       
  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.disease_id != OLD.disease_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER disease_biur
BEFORE INSERT OR UPDATE ON nex.disease FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_disease_biur();

DROP TRIGGER IF EXISTS diseasealias_audr ON nex.disease_alias CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_diseasealias_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('DISEASE_ALIAS'::text, 'DISPLAY_NAME'::text, OLD.alias_id, OLD.display_name, NEW.display_name, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('DISEASE_ALIAS'::text, 'SOURCE_ID'::text, OLD.alias_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (OLD.disease_id != NEW.disease_id) THEN
        PERFORM nex.insertupdatelog('DISEASE_ALIAS'::text, 'DISEASE_ID'::text, OLD.alias_id, OLD.disease_id::text, NEW.disease_id::text, USER);
    END IF;

    IF (OLD.alias_type != NEW.alias_type) THEN
        PERFORM nex.insertupdatelog('DISEASE_ALIAS'::text, 'ALIAS_TYPE'::text, OLD.alias_id, OLD.alias_type, NEW.alias_type, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.alias_id || '[:]' || OLD.display_name || '[:]' || 
             OLD.source_id || '[:]' ||
             OLD.disease_id || '[:]' || OLD.alias_type || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

            PERFORM nex.insertdeletelog('DISEASE_ALIAS'::text, OLD.alias_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER diseasealias_audr
AFTER UPDATE OR DELETE ON nex.disease_alias FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_diseasealias_audr();

DROP TRIGGER IF EXISTS diseasealias_biur ON nex.disease_alias CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_diseasealias_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.alias_id != OLD.alias_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER diseasealias_biur
BEFORE INSERT OR UPDATE ON nex.disease_alias FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_diseasealias_biur();

DROP TRIGGER IF EXISTS diseaserelation_audr ON nex.disease_relation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_diseaserelation_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('DISEASE_RELATION'::text, 'SOURCE_ID'::text, OLD.relation_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

     IF (OLD.parent_id != NEW.parent_id) THEN
        PERFORM nex.insertupdatelog('DISEASE_RELATION'::text, 'PARENT_ID'::text, OLD.relation_id, OLD.parent_id::text, NEW.parent_id::text, USER);
    END IF;

     IF (OLD.child_id != NEW.child_id) THEN
        PERFORM nex.insertupdatelog('DISEASE_RELATION'::text, 'CHILD_ID'::text, OLD.relation_id, OLD.child_id::text, NEW.child_id::text, USER);
    END IF;

    IF (OLD.ro_id != NEW.ro_id) THEN
        PERFORM nex.insertupdatelog('DISEASE_RELATION'::text, 'RO_ID'::text, OLD.relation_id, OLD.ro_id::text, NEW.ro_id::text, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.relation_id || '[:]' || OLD.source_id || '[:]' ||
             OLD.parent_id || '[:]' ||
             OLD.child_id || '[:]' || OLD.ro_id || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('DISEASE_RELATION'::text, OLD.relation_id, v_row, USER);
    RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER diseaserelation_audr
AFTER UPDATE OR DELETE ON nex.disease_relation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_diseaserelation_audr();

DROP TRIGGER IF EXISTS diseaserelation_biur ON nex.disease_relation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_diseaserelation_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

      NEW.created_by := UPPER(NEW.created_by);
      PERFORM nex.checkuser(NEW.created_by);

      RETURN NEW; 

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.relation_id != OLD.relation_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER diseaserelation_biur
BEFORE INSERT OR UPDATE ON nex.disease_relation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_diseaserelation_biur();

DROP TRIGGER IF EXISTS diseaseurl_audr ON nex.disease_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_diseaseurl_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('DISEASE_URL'::text, 'DISPLAY_NAME'::text, OLD.url_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('DISEASE_URL'::text, 'OBJ_URL'::text, OLD.url_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('DISEASE_URL'::text, 'SOURCE_ID'::text, OLD.url_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (OLD.disease_id != NEW.disease_id) THEN
        PERFORM nex.insertupdatelog('DISEASE_URL'::text, 'DISEASE_ID'::text, OLD.url_id, OLD.disease_id::text, NEW.disease_id::text, USER);
    END IF;

    IF (OLD.url_type != NEW.url_type) THEN
        PERFORM nex.insertupdatelog('DISEASE_URL'::text, 'URL_TYPE'::text, OLD.url_id, OLD.url_type, NEW.url_type, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.url_id || '[:]' || OLD.display_name || '[:]' ||
             OLD.obj_url || '[:]' || OLD.source_id || '[:]' || 
             OLD.disease_id || '[:]' || OLD.url_type || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('DISEASE_URL'::text, OLD.url_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER diseaseurl_audr
AFTER UPDATE OR DELETE ON nex.disease_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_diseaseurl_audr();

DROP TRIGGER IF EXISTS diseaseurl_biur ON nex.disease_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_diseaseurl_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.url_id != OLD.url_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;


END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER diseaseurl_biur
BEFORE INSERT OR UPDATE ON nex.disease_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_diseaseurl_biur();


DROP TRIGGER IF EXISTS ec_audr ON nex.ec CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_ec_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.format_name != NEW.format_name) THEN
        PERFORM nex.insertupdatelog('EC'::text, 'FORMAT_NAME'::text, OLD.ec_id, OLD.format_name, NEW.format_name, USER);
    END IF;

    IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('EC'::text, 'DISPLAY_NAME'::text, OLD.ec_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('EC'::text, 'OBJ_URL'::text, OLD.ec_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('EC'::text, 'SOURCE_ID'::text, OLD.ec_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

     IF (OLD.ecid != NEW.ecid) THEN
        PERFORM nex.insertupdatelog('EC'::text, 'ECID'::text, OLD.ec_id, OLD.ecid, NEW.ecid, USER);
    END IF;

    IF (OLD.is_obsolete != NEW.is_obsolete) THEN
	PERFORM nex.insertupdatelog('EC'::text, 'IS_OBSOLETE'::text, OLD.ec_id, OLD.is_obsolete::text, NEW.is_obsolete::text, USER);
    END IF;

    IF (((OLD.description IS NULL) AND (NEW.description IS NOT NULL)) OR ((OLD.description IS NOT NULL) AND (NEW.description IS NULL)) OR (OLD.description != NEW.description)) THEN
        PERFORM nex.insertupdatelog('EC'::text, 'DESCRIPTION'::text, OLD.ec_id, OLD.description, NEW.description, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.ec_id || '[:]' || OLD.format_name || '[:]' ||
             OLD.display_name || '[:]' || OLD.obj_url || '[:]' ||
             OLD.source_id || '[:]' || OLD.ecid || '[:]' || 
             OLD.is_obsolete || '[:]' || coalesce(OLD.description,'') || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('EC'::text, OLD.ec_id, v_row, USER);

    RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER ec_audr
AFTER UPDATE OR DELETE ON nex.ec FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_ec_audr();

DROP TRIGGER IF EXISTS ec_biur ON nex.ec CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_ec_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.ec_id != OLD.ec_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER ec_biur
BEFORE INSERT OR UPDATE ON nex.ec FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_ec_biur();

DROP TRIGGER IF EXISTS ecalias_audr ON nex.ec_alias CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_ecalias_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('EC_ALIAS'::text, 'DISPLAY_NAME'::text, OLD.alias_id, OLD.display_name, NEW.display_name, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('EC_ALIAS'::text, 'SOURCE_ID'::text, OLD.alias_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (OLD.ec_id != NEW.ec_id) THEN
        PERFORM nex.insertupdatelog('EC_ALIAS'::text, 'EC_ID'::text, OLD.alias_id, OLD.ec_id::text, NEW.ec_id::text, USER);
    END IF;

    IF (OLD.alias_type != NEW.alias_type) THEN
        PERFORM nex.insertupdatelog('EC_ALIAS'::text, 'ALIAS_TYPE'::text, OLD.alias_id, OLD.alias_type, NEW.alias_type, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.alias_id || '[:]' || OLD.display_name || '[:]' || 
             OLD.source_id || '[:]' || 
             OLD.ec_id || '[:]' || OLD.alias_type || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('EC_ALIAS'::text, OLD.alias_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER ecalias_audr
AFTER UPDATE OR DELETE ON nex.ec_alias FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_ecalias_audr();

DROP TRIGGER IF EXISTS ecalias_biur ON nex.ec_alias CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_ecalias_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.alias_id != OLD.alias_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER ecalias_biur
BEFORE INSERT OR UPDATE ON nex.ec_alias FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_ecalias_biur();

DROP TRIGGER IF EXISTS ecurl_audr ON nex.ec_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_ecurl_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('EC_URL'::text, 'DISPLAY_NAME'::text, OLD.url_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('EC_URL'::text, 'OBJ_URL'::text, OLD.url_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('EC_URL'::text, 'SOURCE_ID'::text, OLD.url_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (OLD.ec_id != NEW.ec_id) THEN
        PERFORM nex.insertupdatelog('EC_URL'::text, 'EC_ID'::text, OLD.url_id, OLD.ec_id::text, NEW.ec_id::text, USER);
    END IF;

    IF (OLD.url_type != NEW.url_type) THEN
        PERFORM nex.insertupdatelog('EC_URL'::text, 'URL_TYPE'::text, OLD.url_id, OLD.url_type, NEW.url_type, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.url_id || '[:]' || OLD.display_name || '[:]' ||
             OLD.obj_url || '[:]' || OLD.source_id || '[:]' || 
             OLD.ec_id || '[:]' || OLD.url_type || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('EC_URL'::text, OLD.url_id, v_row, USER);

    RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER ecurl_audr
AFTER UPDATE OR DELETE ON nex.ec_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_ecurl_audr();

DROP TRIGGER IF EXISTS ecurl_biur ON nex.ec_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_ecurl_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;
       
  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.url_id != OLD.url_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER ecurl_biur
BEFORE INSERT OR UPDATE ON nex.ec_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_ecurl_biur();


DROP TRIGGER IF EXISTS eco_audr ON nex.eco CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_eco_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.format_name != NEW.format_name) THEN
        PERFORM nex.insertupdatelog('ECO'::text, 'FORMAT_NAME'::text, OLD.eco_id, OLD.format_name, NEW.format_name, USER);
    END IF;

     IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('ECO'::text, 'DISPLAY_NAME'::text, OLD.eco_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('ECO'::text, 'OBJ_URL'::text, OLD.eco_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('ECO'::text, 'SOURCE_ID'::text, OLD.eco_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (OLD.ecoid != NEW.ecoid) THEN
        PERFORM nex.insertupdatelog('ECO'::text, 'ECOID'::text, OLD.eco_id, OLD.ecoid, NEW.ecoid, USER);
    END IF;

    IF (OLD.is_obsolete != NEW.is_obsolete) THEN
	PERFORM nex.insertupdatelog('ECO'::text, 'IS_OBSOLETE'::text, OLD.eco_id, OLD.is_obsolete::text, NEW.is_obsolete::text, USER);
    END IF;

    IF (((OLD.description IS NULL) AND (NEW.description IS NOT NULL)) OR ((OLD.description IS NOT NULL) AND (NEW.description IS NULL)) OR (OLD.description != NEW.description)) THEN
        PERFORM nex.insertupdatelog('ECO'::text, 'DESCRIPTION'::text, OLD.eco_id, OLD.description, NEW.description, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.eco_id || '[:]' || OLD.format_name || '[:]' ||
             OLD.display_name || '[:]' || OLD.obj_url || '[:]' ||
             OLD.source_id || '[:]' || OLD.ecoid || '[:]' || 
             OLD.is_obsolete || '[:]' || coalesce(OLD.description,'') || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

            PERFORM nex.insertdeletelog('ECO'::text, OLD.eco_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER eco_audr
AFTER UPDATE OR DELETE ON nex.eco FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_eco_audr();

DROP TRIGGER IF EXISTS eco_biur ON nex.eco CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_eco_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

      NEW.created_by := UPPER(NEW.created_by);
      PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.eco_id != OLD.eco_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER eco_biur
BEFORE INSERT OR UPDATE ON nex.eco FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_eco_biur();

DROP TRIGGER IF EXISTS ecoalias_audr ON nex.eco_alias CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_ecoalias_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('ECO_ALIAS'::text, 'DISPLAY_NAME'::text, OLD.alias_id, OLD.display_name, NEW.display_name, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('ECO_ALIAS'::text, 'SOURCE_ID'::text, OLD.alias_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (OLD.eco_id != NEW.eco_id) THEN
        PERFORM nex.insertupdatelog('ECO_ALIAS'::text, 'ECO_ID'::text, OLD.alias_id, OLD.eco_id::text, NEW.eco_id::text, USER);
    END IF;

    IF (OLD.alias_type != NEW.alias_type) THEN
        PERFORM nex.insertupdatelog('ECO_ALIAS'::text, 'ALIAS_TYPE'::text, OLD.alias_id, OLD.alias_type, NEW.alias_type, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.alias_id || '[:]' || OLD.display_name || '[:]' || 
             OLD.source_id || '[:]' || 
             OLD.eco_id || '[:]' || OLD.alias_type || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('ECO_ALIAS'::text, OLD.alias_id, v_row, USER);

    RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER ecoalias_audr
AFTER UPDATE OR DELETE ON nex.eco_alias FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_ecoalias_audr();

DROP TRIGGER IF EXISTS ecoalias_biur ON nex.eco_alias CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_ecoalias_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

      NEW.created_by := UPPER(NEW.created_by);
      PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.alias_id != OLD.alias_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER ecoalias_biur
BEFORE INSERT OR UPDATE ON nex.eco_alias FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_ecoalias_biur();

DROP TRIGGER IF EXISTS ecorelation_audr ON nex.eco_relation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_ecorelation_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('ECO_RELATION'::text, 'SOURCE_ID'::text, OLD.relation_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

     IF (OLD.parent_id != NEW.parent_id) THEN
        PERFORM nex.insertupdatelog('ECO_RELATION'::text, 'PARENT_ID'::text, OLD.relation_id, OLD.parent_id::text, NEW.parent_id::text, USER);
    END IF;

     IF (OLD.child_id != NEW.child_id) THEN
        PERFORM nex.insertupdatelog('ECO_RELATION'::text, 'CHILD_ID'::text, OLD.relation_id, OLD.child_id::text, NEW.child_id::text, USER);
    END IF;

    IF (OLD.ro_id != NEW.ro_id) THEN
        PERFORM nex.insertupdatelog('ECO_RELATION'::text, 'RO_ID'::text, OLD.relation_id, OLD.ro_id::text, NEW.ro_id::text, USER);
    END IF;

     RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.relation_id || '[:]' || OLD.source_id || '[:]' ||
             OLD.parent_id || '[:]' ||
             OLD.child_id || '[:]' || OLD.ro_id || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('ECO_RELATION'::text, OLD.relation_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER ecorelation_audr
AFTER UPDATE OR DELETE ON nex.eco_relation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_ecorelation_audr();

DROP TRIGGER IF EXISTS ecorelation_biur ON nex.eco_relation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_ecorelation_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;
       
  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.relation_id != OLD.relation_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER ecorelation_biur
BEFORE INSERT OR UPDATE ON nex.eco_relation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_ecorelation_biur();

DROP TRIGGER IF EXISTS ecourl_audr ON nex.eco_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_ecourl_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('ECO_URL'::text, 'DISPLAY_NAME'::text, OLD.url_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('ECO_URL'::text, 'OBJ_URL'::text, OLD.url_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('ECO_URL'::text, 'SOURCE_ID'::text, OLD.url_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (OLD.eco_id != NEW.eco_id) THEN
        PERFORM nex.insertupdatelog('ECO_URL'::text, 'ECO_ID'::text, OLD.url_id, OLD.eco_id::text, NEW.eco_id::text, USER);
    END IF;

    IF (OLD.url_type != NEW.url_type) THEN
        PERFORM nex.insertupdatelog('ECO_URL'::text, 'URL_TYPE'::text, OLD.url_id, OLD.url_type, NEW.url_type, USER);
    END IF;

    RETURN NEW;
    
  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.url_id || '[:]' || OLD.display_name || '[:]' ||
             OLD.obj_url || '[:]' || OLD.source_id || '[:]' ||
             OLD.eco_id || '[:]' || OLD.url_type || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('ECO_URL'::text, OLD.url_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER ecourl_audr
AFTER UPDATE OR DELETE ON nex.eco_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_ecourl_audr();

DROP TRIGGER IF EXISTS ecourl_biur ON nex.eco_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_ecourl_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;
       
  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.url_id != OLD.url_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER ecourl_biur
BEFORE INSERT OR UPDATE ON nex.eco_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_ecourl_biur();


DROP TRIGGER IF EXISTS edam_audr ON nex.edam CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_edam_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.format_name != NEW.format_name) THEN
        PERFORM nex.insertupdatelog('EDAM'::text, 'FORMAT_NAME'::text, OLD.edam_id, OLD.format_name, NEW.format_name, USER);
    END IF;

     IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('EDAM'::text, 'DISPLAY_NAME'::text, OLD.edam_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('EDAM'::text, 'OBJ_URL'::text, OLD.edam_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('EDAM'::text, 'SOURCE_ID'::text, OLD.edam_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

     IF (OLD.edamid != NEW.edamid) THEN
        PERFORM nex.insertupdatelog('EDAM'::text, 'EDAMID'::text, OLD.edam_id, OLD.edamid, NEW.edamid, USER);
    END IF;

     IF (OLD.edam_namespace != NEW.edam_namespace) THEN
        PERFORM nex.insertupdatelog('EDAM'::text, 'EDAM_NAMESPACE'::text, OLD.edam_id, OLD.edam_namespace, NEW.edam_namespace, USER);
    END IF;

    IF (OLD.is_obsolete != NEW.is_obsolete) THEN
	    PERFORM nex.insertupdatelog('EDAM'::text, 'IS_OBSOLETE'::text, OLD.edam_id, OLD.is_obsolete::text, NEW.is_obsolete::text, USER);
    END IF;

    IF (((OLD.description IS NULL) AND (NEW.description IS NOT NULL)) OR ((OLD.description IS NOT NULL) AND (NEW.description IS NULL)) OR (OLD.description != NEW.description)) THEN
        PERFORM nex.insertupdatelog('EDAM'::text, 'DESCRIPTION'::text, OLD.edam_id, OLD.description, NEW.description, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.edam_id || '[:]' || OLD.format_name || '[:]' ||
             OLD.display_name || '[:]' || OLD.obj_url || '[:]' ||
             OLD.source_id || '[:]' || OLD.edamid || '[:]' ||
             OLD.edam_namespace || '[:]' || OLD.is_obsolete || '[:]' || 
             coalesce(OLD.description,'') || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('EDAM'::text, OLD.edam_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER edam_audr
AFTER UPDATE OR DELETE ON nex.edam FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_edam_audr();

DROP TRIGGER IF EXISTS edam_biur ON nex.edam CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_edam_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.edam_id != OLD.edam_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER edam_biur
BEFORE INSERT OR UPDATE ON nex.edam FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_edam_biur();

DROP TRIGGER IF EXISTS edamalias_audr ON nex.edam_alias CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_edamalias_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('EDAM_ALIAS'::text, 'DISPLAY_NAME'::text, OLD.alias_id, OLD.display_name, NEW.display_name, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('EDAM_ALIAS'::text, 'SOURCE_ID'::text, OLD.alias_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (OLD.edam_id != NEW.edam_id) THEN
        PERFORM nex.insertupdatelog('EDAM_ALIAS'::text, 'EDAM_ID'::text, OLD.alias_id, OLD.edam_id::text, NEW.edam_id::text, USER);
    END IF;

    IF (OLD.alias_type != NEW.alias_type) THEN
        PERFORM nex.insertupdatelog('EDAM_ALIAS'::text, 'ALIAS_TYPE'::text, OLD.alias_id, OLD.alias_type, NEW.alias_type, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.alias_id || '[:]' || OLD.display_name || '[:]' || 
             OLD.source_id || '[:]' || 
             OLD.edam_id || '[:]' || OLD.alias_type || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('EDAM_ALIAS'::text, OLD.alias_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER edamalias_audr
AFTER UPDATE OR DELETE ON nex.edam_alias FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_edamalias_audr();

DROP TRIGGER IF EXISTS edamalias_biur ON nex.edam_alias CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_edamalias_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.alias_id != OLD.alias_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER edamalias_biur
BEFORE INSERT OR UPDATE ON nex.edam_alias FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_edamalias_biur();

DROP TRIGGER IF EXISTS edamrelation_audr ON nex.edam_relation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_edamrelation_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('EDAM_RELATION'::text, 'SOURCE_ID'::text, OLD.relation_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

     IF (OLD.parent_id != NEW.parent_id) THEN
        PERFORM nex.insertupdatelog('EDAM_RELATION'::text, 'PARENT_ID'::text, OLD.relation_id, OLD.parent_id::text, NEW.parent_id::text, USER);
    END IF;

     IF (OLD.child_id != NEW.child_id) THEN
        PERFORM nex.insertupdatelog('EDAM_RELATION'::text, 'CHILD_ID'::text, OLD.relation_id, OLD.child_id::text, NEW.child_id::text, USER);
    END IF;

     IF (OLD.ro_id != NEW.ro_id) THEN
        PERFORM nex.insertupdatelog('EDAM_RELATION'::text, 'RO_ID'::text, OLD.relation_id, OLD.ro_id::text, NEW.ro_id::text, USER);
     END IF;

     RETURN NEW;
     
  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.relation_id || '[:]' || OLD.source_id || '[:]' ||
             OLD.parent_id || '[:]' ||
             OLD.child_id || '[:]' || OLD.ro_id || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('EDAM_RELATION'::text, OLD.relation_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER edamrelation_audr
AFTER UPDATE OR DELETE ON nex.edam_relation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_edamrelation_audr();

DROP TRIGGER IF EXISTS edamrelation_biur ON nex.edam_relation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_edamrelation_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.relation_id != OLD.relation_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER edamrelation_biur
BEFORE INSERT OR UPDATE ON nex.edam_relation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_edamrelation_biur();

DROP TRIGGER IF EXISTS edamurl_audr ON nex.edam_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_edamurl_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

     IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('EDAM_URL'::text, 'DISPLAY_NAME'::text, OLD.url_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('EDAM_URL'::text, 'OBJ_URL'::text, OLD.url_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('EDAM_URL'::text, 'SOURCE_ID'::text, OLD.url_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (OLD.edam_id != NEW.edam_id) THEN
        PERFORM nex.insertupdatelog('EDAM_URL'::text, 'EDAM_ID'::text, OLD.url_id, OLD.edam_id::text, NEW.edam_id::text, USER);
    END IF;

    IF (OLD.url_type != NEW.url_type) THEN
        PERFORM nex.insertupdatelog('EDAM_URL'::text, 'URL_TYPE'::text, OLD.url_id, OLD.url_type, NEW.url_type, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.url_id || '[:]' || OLD.display_name || '[:]' ||
             OLD.obj_url || '[:]' || OLD.source_id || '[:]' || 
             OLD.edam_id || '[:]' || OLD.url_type || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('EDAM_URL'::text, OLD.url_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER edamurl_audr
AFTER UPDATE OR DELETE ON nex.edam_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_edamurl_audr();

DROP TRIGGER IF EXISTS edamurl_biur ON nex.edam_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_edamurl_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.url_id != OLD.url_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER edamurl_biur
BEFORE INSERT OR UPDATE ON nex.edam_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_edamurl_biur();


DROP TRIGGER IF EXISTS go_audr ON nex.go CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_go_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.format_name != NEW.format_name) THEN
        PERFORM nex.insertupdatelog('GO'::text, 'FORMAT_NAME'::text, OLD.go_id, OLD.format_name, NEW.format_name, USER);
    END IF;

     IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('GO'::text, 'DISPLAY_NAME'::text, OLD.go_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('GO'::text, 'OBJ_URL'::text, OLD.go_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('GO'::text, 'SOURCE_ID'::text, OLD.go_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

     IF (OLD.goid != NEW.goid) THEN
        PERFORM nex.insertupdatelog('GO'::text, 'GOID'::text, OLD.go_id, OLD.goid, NEW.goid, USER);
    END IF;

     IF (OLD.go_namespace != NEW.go_namespace) THEN
        PERFORM nex.insertupdatelog('GO'::text, 'GO_NAMESPACE'::text, OLD.go_id, OLD.go_namespace, NEW.go_namespace, USER);
    END IF;

    IF (OLD.is_obsolete != NEW.is_obsolete) THEN
	    PERFORM nex.insertupdatelog('GO'::text, 'IS_OBSOLETE'::text, OLD.go_id, OLD.is_obsolete::text, NEW.is_obsolete::text, USER);
    END IF;

    IF (((OLD.description IS NULL) AND (NEW.description IS NOT NULL)) OR ((OLD.description IS NOT NULL) AND (NEW.description IS NULL)) OR (OLD.description != NEW.description)) THEN
        PERFORM nex.insertupdatelog('GO'::text, 'DESCRIPTION'::text, OLD.go_id, OLD.description, NEW.description, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.go_id || '[:]' || OLD.format_name || '[:]' ||
             OLD.display_name || '[:]' || OLD.obj_url || '[:]' ||
             OLD.source_id || '[:]' || OLD.goid || '[:]' ||
             OLD.go_namespace || '[:]' || OLD.is_obsolete || '[:]' ||
             coalesce(OLD.description,'') || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('GO'::text, OLD.go_id, v_row, USER);

    RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER go_audr
	AFTER UPDATE OR DELETE ON nex.go FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_go_audr();

DROP TRIGGER IF EXISTS go_biur ON nex.go CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_go_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.go_id != OLD.go_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER go_biur
BEFORE INSERT OR UPDATE ON nex.go FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_go_biur();

DROP TRIGGER IF EXISTS goalias_audr ON nex.go_alias CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_goalias_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
    IF (TG_OP = 'UPDATE') THEN

      IF (OLD.display_name != NEW.display_name)THEN
          PERFORM nex.insertupdatelog('GO_ALIAS'::text, 'DISPLAY_NAME'::text, OLD.alias_id, OLD.display_name, NEW.display_name, USER);
      END IF;

      IF (OLD.source_id != NEW.source_id) THEN
	  PERFORM nex.insertupdatelog('GO_ALIAS'::text, 'SOURCE_ID'::text, OLD.alias_id, OLD.source_id::text, NEW.source_id::text, USER);
     END IF;

      IF (OLD.go_id != NEW.go_id) THEN
	 PERFORM nex.insertupdatelog('GO_ALIAS'::text, 'GO_ID'::text, OLD.alias_id, OLD.go_id::text, NEW.go_id::text, USER);
      END IF;

     IF (OLD.alias_type != NEW.alias_type) THEN
 	 PERFORM nex.insertupdatelog('GO_ALIAS'::text, 'ALIAS_TYPE'::text, OLD.alias_id, OLD.alias_type, NEW.alias_type, USER);
     END IF;

     RETURN NEW;
     
  ELSIF (TG_OP = 'DELETE') THEN

     v_row := OLD.alias_id || '[:]' || OLD.display_name || '[:]' ||
              OLD.source_id || '[:]' || OLD.go_id || '[:]' || 
              OLD.alias_type || '[:]' ||
              OLD.date_created || '[:]' || OLD.created_by;

              PERFORM nex.insertdeletelog('GO_ALIAS'::text, OLD.alias_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER goalias_audr
AFTER UPDATE OR DELETE ON nex.go_alias FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_goalias_audr();

DROP TRIGGER IF EXISTS goalias_biur ON nex.go_alias CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_goalias_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.alias_id != OLD.alias_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER goalias_biur
BEFORE INSERT OR UPDATE ON nex.go_alias FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_goalias_biur();

DROP TRIGGER IF EXISTS gorelation_audr ON nex.go_relation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_gorelation_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('GO_RELATION'::text, 'SOURCE_ID'::text, OLD.relation_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

     IF (OLD.parent_id != NEW.parent_id) THEN
        PERFORM nex.insertupdatelog('GO_RELATION'::text, 'PARENT_ID'::text, OLD.relation_id, OLD.parent_id::text, NEW.parent_id::text, USER);
    END IF;

     IF (OLD.child_id != NEW.child_id) THEN
        PERFORM nex.insertupdatelog('GO_RELATION'::text, 'CHILD_ID'::text, OLD.relation_id, OLD.child_id::text, NEW.child_id::text, USER);
    END IF;

    IF (OLD.ro_id != NEW.ro_id) THEN
        PERFORM nex.insertupdatelog('GO_RELATION'::text, 'RO_ID'::text, OLD.relation_id, OLD.ro_id::text, NEW.ro_id::text, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.relation_id || '[:]' || OLD.source_id || '[:]' ||
             OLD.parent_id || '[:]' ||
             OLD.child_id || '[:]' || OLD.ro_id || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

            PERFORM nex.insertdeletelog('GO_RELATION'::text, OLD.relation_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER gorelation_audr
AFTER UPDATE OR DELETE ON nex.go_relation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_gorelation_audr();

DROP TRIGGER IF EXISTS gorelation_biur ON nex.go_relation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_gorelation_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.relation_id != OLD.relation_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER gorelation_biur
BEFORE INSERT OR UPDATE ON nex.go_relation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_gorelation_biur();

DROP TRIGGER IF EXISTS gourl_audr ON nex.go_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_gourl_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

     IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('GO_URL'::text, 'DISPLAY_NAME'::text, OLD.url_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('GO_URL'::text, 'OBJ_URL'::text, OLD.url_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('GO_URL'::text, 'SOURCE_ID'::text, OLD.url_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (OLD.go_id != NEW.go_id) THEN
        PERFORM nex.insertupdatelog('GO_URL'::text, 'GO_ID'::text, OLD.url_id, OLD.go_id::text, NEW.go_id::text, USER);
    END IF;

    IF (OLD.url_type != NEW.url_type) THEN
        PERFORM nex.insertupdatelog('GO_URL'::text, 'URL_TYPE'::text, OLD.url_id, OLD.url_type, NEW.url_type, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.url_id || '[:]' || OLD.display_name || '[:]' ||
             OLD.obj_url || '[:]' || OLD.source_id || '[:]' || 
             OLD.go_id || '[:]' || OLD.url_type || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

            PERFORM nex.insertdeletelog('GO_URL'::text, OLD.url_id, v_row, USER);

    RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER gourl_audr
AFTER UPDATE OR DELETE ON nex.go_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_gourl_audr();

DROP TRIGGER IF EXISTS gourl_biur ON nex.go_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_gourl_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.url_id != OLD.url_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER gourl_biur
BEFORE INSERT OR UPDATE ON nex.go_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_gourl_biur();


DROP TRIGGER IF EXISTS keyword_audr ON nex.keyword CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_keyword_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.format_name != NEW.format_name) THEN
        PERFORM nex.insertupdatelog('KEYWORD'::text, 'FORMAT_NAME'::text, OLD.keyword_id, OLD.format_name, NEW.format_name, USER);
    END IF;

     IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('KEYWORD'::text, 'DISPLAY_NAME'::text, OLD.keyword_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('KEYWORD'::text, 'OBJ_URL'::text, OLD.keyword_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('KEYWORD'::text, 'SOURCE_ID'::text, OLD.keyword_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (OLD.is_obsolete != NEW.is_obsolete) THEN
	     PERFORM nex.insertupdatelog('KEYWORD'::text, 'IS_OBSOLETE'::text, OLD.keyword_id, OLD.is_obsolete::text, NEW.is_obsolete::text, USER);
    END IF;

    IF (((OLD.description IS NULL) AND (NEW.description IS NOT NULL)) OR ((OLD.description IS NOT NULL) AND (NEW.description IS NULL)) OR (OLD.description != NEW.description)) THEN
        PERFORM nex.insertupdatelog('KEYWORD'::text, 'DESCRIPTION'::text, OLD.keyword_id, OLD.description, NEW.description, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.keyword_id || '[:]' || OLD.format_name || '[:]' ||
             OLD.display_name || '[:]' || OLD.obj_url || '[:]' ||
             OLD.source_id || '[:]' || OLD.is_obsolete || '[:]' ||
             coalesce(OLD.description,'') || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

            PERFORM nex.insertdeletelog('KEYWORD'::text, OLD.keyword_id, v_row, USER);
    RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER keyword_audr
AFTER UPDATE OR DELETE ON nex.keyword FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_keyword_audr();

DROP TRIGGER IF EXISTS keyword_biur ON nex.keyword CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_keyword_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;
       
  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.keyword_id != OLD.keyword_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;
    
    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER keyword_biur
BEFORE INSERT OR UPDATE ON nex.keyword FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_keyword_biur();


DROP TRIGGER IF EXISTS obi_audr ON nex.obi CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_obi_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.format_name != NEW.format_name) THEN
        PERFORM nex.insertupdatelog('OBI'::text, 'FORMAT_NAME'::text, OLD.obi_id, OLD.format_name, NEW.format_name, USER);
    END IF;

    IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('OBI'::text, 'DISPLAY_NAME'::text, OLD.obi_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('OBI'::text, 'OBJ_URL'::text, OLD.obi_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('OBI'::text, 'SOURCE_ID'::text, OLD.obi_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (OLD.obiid != NEW.obiid) THEN
        PERFORM nex.insertupdatelog('OBI'::text, 'OBIID'::text, OLD.obi_id, OLD.obiid, NEW.obiid, USER);
    END IF;

    IF (OLD.is_obsolete != NEW.is_obsolete) THEN
	     PERFORM nex.insertupdatelog('OBI'::text, 'IS_OBSOLETE'::text, OLD.obi_id, OLD.is_obsolete::text, NEW.is_obsolete::text, USER);
    END IF;

    IF (((OLD.description IS NULL) AND (NEW.description IS NOT NULL)) OR ((OLD.description IS NOT NULL) AND (NEW.description IS NULL)) OR (OLD.description != NEW.description)) THEN
        PERFORM nex.insertupdatelog('OBI'::text, 'DESCRIPTION'::text, OLD.obi_id, OLD.description, NEW.description, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.obi_id || '[:]' || OLD.format_name || '[:]' ||
             OLD.display_name || '[:]' || OLD.obj_url || '[:]' ||
             OLD.source_id || '[:]' || OLD.obiid || '[:]' || 
             OLD.is_obsolete || '[:]' || coalesce(OLD.description,'') || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('OBI'::text, OLD.obi_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER obi_audr
AFTER UPDATE OR DELETE ON nex.obi FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_obi_audr();

DROP TRIGGER IF EXISTS obi_biur ON nex.obi CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_obi_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.obi_id != OLD.obi_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER obi_biur
BEFORE INSERT OR UPDATE ON nex.obi FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_obi_biur();

DROP TRIGGER IF EXISTS obirelation_audr ON nex.obi_relation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_obirelation_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('OBI_RELATION'::text, 'SOURCE_ID'::text, OLD.relation_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

     IF (OLD.parent_id != NEW.parent_id) THEN
        PERFORM nex.insertupdatelog('OBI_RELATION'::text, 'PARENT_ID'::text, OLD.relation_id, OLD.parent_id::text, NEW.parent_id::text, USER);
    END IF;

     IF (OLD.child_id != NEW.child_id) THEN
        PERFORM nex.insertupdatelog('OBI_RELATION'::text, 'CHILD_ID'::text, OLD.relation_id, OLD.child_id::text, NEW.child_id::text, USER);
    END IF;

    IF (OLD.ro_id != NEW.ro_id) THEN
        PERFORM nex.insertupdatelog('OBI_RELATION'::text, 'RO_ID'::text, OLD.relation_id, OLD.ro_id::text, NEW.ro_id::text, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.relation_id || '[:]' || OLD.source_id || '[:]' ||
             OLD.parent_id || '[:]' ||
             OLD.child_id || '[:]' || OLD.ro_id || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('OBI_RELATION'::text, OLD.relation_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER obirelation_audr
AFTER UPDATE OR DELETE ON nex.obi_relation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_obirelation_audr();

DROP TRIGGER IF EXISTS obirelation_biur ON nex.obi_relation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_obirelation_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.relation_id != OLD.relation_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER obirelation_biur
BEFORE INSERT OR UPDATE ON nex.obi_relation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_obirelation_biur();

DROP TRIGGER IF EXISTS obiurl_audr ON nex.obi_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_obiurl_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('OBI_URL'::text, 'DISPLAY_NAME'::text, OLD.url_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('OBI_URL'::text, 'OBJ_URL'::text, OLD.url_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('OBI_URL'::text, 'SOURCE_ID'::text, OLD.url_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (OLD.obi_id != NEW.obi_id) THEN
        PERFORM nex.insertupdatelog('OBI_URL'::text, 'OBI_ID'::text, OLD.url_id, OLD.obi_id::text, NEW.obi_id::text, USER);
    END IF;

    IF (OLD.url_type != NEW.url_type) THEN
        PERFORM nex.insertupdatelog('OBI_URL'::text, 'URL_TYPE'::text, OLD.url_id, OLD.url_type, NEW.url_type, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.url_id || '[:]' || OLD.display_name || '[:]' ||
             OLD.obj_url || '[:]' || OLD.source_id || '[:]' || 
             OLD.obi_id || '[:]' || OLD.url_type || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('OBI_URL'::text, OLD.url_id, v_row, USER);

      RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER obiurl_audr
AFTER UPDATE OR DELETE ON nex.obi_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_obiurl_audr();

DROP TRIGGER IF EXISTS obiurl_biur ON nex.obi_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_obiurl_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.url_id != OLD.url_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER obiurl_biur
BEFORE INSERT OR UPDATE ON nex.obi_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_obiurl_biur();

CREATE OR REPLACE FUNCTION trigger_fct_psimi_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.format_name != NEW.format_name) THEN
        PERFORM nex.insertupdatelog('PSIMI'::text, 'FORMAT_NAME'::text, OLD.psimi_id, OLD.format_name, NEW.format_name, USER);
    END IF;

    IF (OLD.display_name != NEW.display_name) THEN
    PERFORM nex.insertupdatelog('PSIMI'::text, 'DISPLAY_NAME'::text, OLD.psimi_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('PSIMI'::text, 'OBJ_URL'::text, OLD.psimi_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('PSIMI'::text, 'SOURCE_ID'::text, OLD.psimi_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (OLD.psimiid != NEW.psimiid) THEN
        PERFORM nex.insertupdatelog('PSIMI'::text, 'PSIMIID'::text, OLD.psimi_id, OLD.psimiid, NEW.psimiid, USER);
    END IF;

    IF (OLD.is_obsolete != NEW.is_obsolete) THEN
        PERFORM nex.insertupdatelog('PSIMI'::text, 'IS_OBSOLETE'::text, OLD.psimi_id, OLD.is_obsolete::text, NEW.is_obsolete::text, USER);
    END IF;

    IF (((OLD.description IS NULL) AND (NEW.description IS NOT NULL)) OR ((OLD.description IS NOT NULL) AND (NEW.description IS NULL)) OR (OLD.description != NEW.description)) THEN
        PERFORM nex.insertupdatelog('PSIMI'::text, 'DESCRIPTION'::text, OLD.psimi_id, OLD.description, NEW.description, USER);
    END IF;

     RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.psimi_id || '[:]' || OLD.format_name || '[:]' ||
             OLD.display_name || '[:]' || OLD.obj_url || '[:]' ||
             OLD.source_id || '[:]' || OLD.psimiid || '[:]' ||
             coalesce(OLD.description,'') || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('PSIMI'::text, OLD.psimi_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER psimi_audr
AFTER UPDATE OR DELETE ON nex.psimi FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_psimi_audr();

DROP TRIGGER IF EXISTS psimi_biur ON nex.psimi CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_psimi_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
              PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.psimi_id != OLD.psimi_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER psimi_biur
BEFORE INSERT OR UPDATE ON nex.psimi FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_psimi_biur();

DROP TRIGGER IF EXISTS psimialias_audr ON nex.psimi_alias CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_psimialias_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
    IF (TG_OP = 'UPDATE') THEN

      IF (OLD.display_name != NEW.display_name)THEN
          PERFORM nex.insertupdatelog('PSIMI_ALIAS'::text, 'DISPLAY_NAME'::text, OLD.alias_id, OLD.display_name, NEW.display_name, USER);
      END IF;

      IF (OLD.source_id != NEW.source_id) THEN
      PERFORM nex.insertupdatelog('PSIMI_ALIAS'::text, 'SOURCE_ID'::text, OLD.alias_id, OLD.source_id::text, NEW.source_id::text, USER);
     END IF;

      IF (OLD.psimi_id != NEW.psimi_id) THEN
     PERFORM nex.insertupdatelog('PSIMI_ALIAS'::text, 'PSIMI_ID'::text, OLD.alias_id, OLD.psimi_id::text, NEW.psimi_id::text, USER);
      END IF;

     IF (OLD.alias_type != NEW.alias_type) THEN
     PERFORM nex.insertupdatelog('PSIMI_ALIAS'::text, 'ALIAS_TYPE'::text, OLD.alias_id, OLD.alias_type, NEW.alias_type, USER);
     END IF;

     RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

     v_row := OLD.alias_id || '[:]' || OLD.display_name || '[:]' ||
              OLD.source_id || '[:]' || OLD.psimi_id || '[:]' ||
              OLD.alias_type || '[:]' ||
              OLD.date_created || '[:]' || OLD.created_by;

              PERFORM nex.insertdeletelog('PSIMI_ALIAS'::text, OLD.alias_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER psimialias_audr
AFTER UPDATE OR DELETE ON nex.psimi_alias FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_psimialias_audr();

DROP TRIGGER IF EXISTS psimialias_biur ON nex.psimi_alias CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_psimialias_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.alias_id != OLD.alias_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER psimialias_biur
BEFORE INSERT OR UPDATE ON nex.psimi_alias FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_psimialias_biur();

DROP TRIGGER IF EXISTS psimirelation_audr ON nex.psimi_relation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_psimirelation_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('PSIMI_RELATION'::text, 'SOURCE_ID'::text, OLD.relation_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

     IF (OLD.parent_id != NEW.parent_id) THEN
        PERFORM nex.insertupdatelog('PSIMI_RELATION'::text, 'PARENT_ID'::text, OLD.relation_id, OLD.parent_id::text, NEW.parent_id::text, USER);
    END IF;

     IF (OLD.child_id != NEW.child_id) THEN
        PERFORM nex.insertupdatelog('PSIMI_RELATION'::text, 'CHILD_ID'::text, OLD.relation_id, OLD.child_id::text, NEW.child_id::text, USER);
    END IF;

    IF (OLD.ro_id != NEW.ro_id) THEN
        PERFORM nex.insertupdatelog('PSIMI_RELATION'::text, 'RO_ID'::text, OLD.relation_id, OLD.ro_id::text, NEW.ro_id::text, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.relation_id || '[:]' || OLD.source_id || '[:]' ||
             OLD.parent_id || '[:]' ||
             OLD.child_id || '[:]' || OLD.ro_id || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('PSIMI_RELATION'::text, OLD.relation_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER psimirelation_audr
AFTER UPDATE OR DELETE ON nex.psimi_relation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_psimirelation_audr();

DROP TRIGGER IF EXISTS psimirelation_biur ON nex.psimi_relation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_psimirelation_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.relation_id != OLD.relation_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER psimirelation_biur
BEFORE INSERT OR UPDATE ON nex.psimi_relation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_psimirelation_biur();

DROP TRIGGER IF EXISTS psimiurl_audr ON nex.psimi_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_psimiurl_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('PSIMI_URL'::text, 'DISPLAY_NAME'::text, OLD.url_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('PSIMI_URL'::text, 'OBJ_URL'::text, OLD.url_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('PSIMI_URL'::text, 'SOURCE_ID'::text, OLD.url_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (OLD.psimi_id != NEW.psimi_id) THEN
        PERFORM nex.insertupdatelog('PSIMI_URL'::text, 'PSIMI_ID'::text, OLD.url_id, OLD.psimi_id::text, NEW.psimi_id::text, USER);
    END IF;

    IF (OLD.url_type != NEW.url_type) THEN
        PERFORM nex.insertupdatelog('PSIMI_URL'::text, 'URL_TYPE'::text, OLD.url_id, OLD.url_type, NEW.url_type, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.url_id || '[:]' || OLD.display_name || '[:]' ||
             OLD.obj_url || '[:]' || OLD.source_id || '[:]' ||
             OLD.psimi_id || '[:]' || OLD.url_type || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('PSIMI_URL'::text, OLD.url_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER psimiurl_audr
AFTER UPDATE OR DELETE ON nex.psimi_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_psimiurl_audr();

DROP TRIGGER IF EXISTS psimiurl_biur ON nex.psimi_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_psimiurl_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;
  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.url_id != OLD.url_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER psimiurl_biur
BEFORE INSERT OR UPDATE ON nex.psimi_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_psimiurl_biur();


DROP TRIGGER IF EXISTS psimod_audr ON nex.psimod CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_psimod_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.format_name != NEW.format_name) THEN
        PERFORM nex.insertupdatelog('PSIMOD'::text, 'FORMAT_NAME'::text, OLD.psimod_id, OLD.format_name, NEW.format_name, USER);
    END IF;

    IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('PSIMOD'::text, 'DISPLAY_NAME'::text, OLD.psimod_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('PSIMOD'::text, 'OBJ_URL'::text, OLD.psimod_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('PSIMOD'::text, 'SOURCE_ID'::text, OLD.psimod_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (OLD.psimodid != NEW.psimodid) THEN
        PERFORM nex.insertupdatelog('PSIMOD'::text, 'PSIMODID'::text, OLD.psimod_id, OLD.psimodid, NEW.psimodid, USER);
    END IF;

    IF (OLD.is_obsolete != NEW.is_obsolete) THEN
	    PERFORM nex.insertupdatelog('PSIMOD'::text, 'IS_OBSOLETE'::text, OLD.psimod_id, OLD.is_obsolete::text, NEW.is_obsolete::text, USER);
    END IF;

    IF (((OLD.description IS NULL) AND (NEW.description IS NOT NULL)) OR ((OLD.description IS NOT NULL) AND (NEW.description IS NULL)) OR (OLD.description != NEW.description)) THEN
        PERFORM nex.insertupdatelog('PSIMOD'::text, 'DESCRIPTION'::text, OLD.psimod_id, OLD.description, NEW.description, USER);
    END IF;

     RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.psimod_id || '[:]' || OLD.format_name || '[:]' ||
             OLD.display_name || '[:]' || OLD.obj_url || '[:]' ||
             OLD.source_id || '[:]' || OLD.psimodid || '[:]' || 
             coalesce(OLD.description,'') || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('PSIMOD'::text, OLD.psimod_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER psimod_audr
AFTER UPDATE OR DELETE ON nex.psimod FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_psimod_audr();

DROP TRIGGER IF EXISTS psimod_biur ON nex.psimod CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_psimod_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
              PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.psimod_id != OLD.psimod_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER psimod_biur
BEFORE INSERT OR UPDATE ON nex.psimod FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_psimod_biur();

DROP TRIGGER IF EXISTS psimodrelation_audr ON nex.psimod_relation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_psimodrelation_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('PSIMOD_RELATION'::text, 'SOURCE_ID'::text, OLD.relation_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

     IF (OLD.parent_id != NEW.parent_id) THEN
        PERFORM nex.insertupdatelog('PSIMOD_RELATION'::text, 'PARENT_ID'::text, OLD.relation_id, OLD.parent_id::text, NEW.parent_id::text, USER);
    END IF;

     IF (OLD.child_id != NEW.child_id) THEN
        PERFORM nex.insertupdatelog('PSIMOD_RELATION'::text, 'CHILD_ID'::text, OLD.relation_id, OLD.child_id::text, NEW.child_id::text, USER);
    END IF;

    IF (OLD.ro_id != NEW.ro_id) THEN
        PERFORM nex.insertupdatelog('PSIMOD_RELATION'::text, 'RO_ID'::text, OLD.relation_id, OLD.ro_id::text, NEW.ro_id::text, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.relation_id || '[:]' || OLD.source_id || '[:]' ||
             OLD.parent_id || '[:]' ||
             OLD.child_id || '[:]' || OLD.ro_id || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('PSIMOD_RELATION'::text, OLD.relation_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER psimodrelation_audr
AFTER UPDATE OR DELETE ON nex.psimod_relation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_psimodrelation_audr();

DROP TRIGGER IF EXISTS psimodrelation_biur ON nex.psimod_relation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_psimodrelation_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;
       
  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.relation_id != OLD.relation_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER psimodrelation_biur
BEFORE INSERT OR UPDATE ON nex.psimod_relation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_psimodrelation_biur();

DROP TRIGGER IF EXISTS psimodurl_audr ON nex.psimod_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_psimodurl_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('PSIMOD_URL'::text, 'DISPLAY_NAME'::text, OLD.url_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('PSIMOD_URL'::text, 'OBJ_URL'::text, OLD.url_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('PSIMOD_URL'::text, 'SOURCE_ID'::text, OLD.url_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (OLD.psimod_id != NEW.psimod_id) THEN
        PERFORM nex.insertupdatelog('PSIMOD_URL'::text, 'PSIMOD_ID'::text, OLD.url_id, OLD.psimod_id::text, NEW.psimod_id::text, USER);
    END IF;

    IF (OLD.url_type != NEW.url_type) THEN
        PERFORM nex.insertupdatelog('PSIMOD_URL'::text, 'URL_TYPE'::text, OLD.url_id, OLD.url_type, NEW.url_type, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.url_id || '[:]' || OLD.display_name || '[:]' ||
             OLD.obj_url || '[:]' || OLD.source_id || '[:]' || 
             OLD.psimod_id || '[:]' || OLD.url_type || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('PSIMOD_URL'::text, OLD.url_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER psimodurl_audr
AFTER UPDATE OR DELETE ON nex.psimod_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_psimodurl_audr();

DROP TRIGGER IF EXISTS psimodurl_biur ON nex.psimod_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_psimodurl_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;
  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.url_id != OLD.url_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER psimodurl_biur
BEFORE INSERT OR UPDATE ON nex.psimod_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_psimodurl_biur();


DROP TRIGGER IF EXISTS ro_audr ON nex.ro CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_ro_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.format_name != NEW.format_name) THEN
        PERFORM nex.insertupdatelog('RO'::text, 'FORMAT_NAME'::text, OLD.ro_id, OLD.format_name, NEW.format_name, USER);
    END IF;

    IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('RO'::text, 'DISPLAY_NAME'::text, OLD.ro_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('RO'::text, 'OBJ_URL'::text, OLD.ro_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('RO'::text, 'SOURCE_ID'::text, OLD.ro_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (OLD.roid != NEW.roid) THEN
        PERFORM nex.insertupdatelog('RO'::text, 'ROID'::text, OLD.ro_id, OLD.roid, NEW.roid, USER);
    END IF;

    IF (OLD.is_obsolete != NEW.is_obsolete) THEN
	    PERFORM nex.insertupdatelog('RO'::text, 'IS_OBSOLETE'::text, OLD.ro_id, OLD.is_obsolete::text, NEW.is_obsolete::text, USER);
    END IF;

    IF (((OLD.description IS NULL) AND (NEW.description IS NOT NULL)) OR ((OLD.description IS NOT NULL) AND (NEW.description IS NULL)) OR (OLD.description != NEW.description)) THEN
        PERFORM nex.insertupdatelog('RO'::text, 'DESCRIPTION'::text, OLD.ro_id, OLD.description, NEW.description, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.ro_id || '[:]' || OLD.format_name || '[:]' ||
             OLD.display_name || '[:]' || OLD.obj_url || '[:]' ||
             OLD.source_id || '[:]' || OLD.ro_id || '[:]' || 
             OLD.is_obsolete || '[:]' || coalesce(OLD.description,'') || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('RO'::text, OLD.ro_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER ro_audr
AFTER UPDATE OR DELETE ON nex.ro FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_ro_audr();

DROP TRIGGER IF EXISTS ro_biur ON nex.ro CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_ro_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.ro_id != OLD.ro_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';
 
CREATE TRIGGER ro_biur
BEFORE INSERT OR UPDATE ON nex.ro FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_ro_biur();

DROP TRIGGER IF EXISTS rourl_audr ON nex.ro_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_rourl_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('RO_URL'::text, 'DISPLAY_NAME'::text, OLD.url_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('RO_URL'::text, 'OBJ_URL'::text, OLD.url_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('RO_URL'::text, 'SOURCE_ID'::text, OLD.url_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (OLD.ro_id != NEW.ro_id) THEN
        PERFORM nex.insertupdatelog('RO_URL'::text, 'RO_ID'::text, OLD.url_id, OLD.ro_id::text, NEW.ro_id::text, USER);
    END IF;

    IF (OLD.url_type != NEW.url_type) THEN
        PERFORM nex.insertupdatelog('RO_URL'::text, 'URL_TYPE'::text, OLD.url_id, OLD.url_type, NEW.url_type, USER);
    END IF;

    RETURN NEW;
    
  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.url_id || '[:]' || OLD.display_name || '[:]' ||
             OLD.obj_url || '[:]' || OLD.source_id || '[:]' || 
             OLD.ro_id || '[:]' || OLD.url_type || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('RO_URL'::text, OLD.url_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER rourl_audr
AFTER UPDATE OR DELETE ON nex.ro_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_rourl_audr();

DROP TRIGGER IF EXISTS rourl_biur ON nex.ro_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_rourl_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.url_id != OLD.url_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER rourl_biur
BEFORE INSERT OR UPDATE ON nex.ro_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_rourl_biur();


DROP TRIGGER IF EXISTS so_audr ON nex.so CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_so_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.format_name != NEW.format_name) THEN
        PERFORM nex.insertupdatelog('SO'::text, 'FORMAT_NAME'::text, OLD.so_id, OLD.format_name, NEW.format_name, USER);
    END IF;

     IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('SO'::text, 'DISPLAY_NAME'::text, OLD.so_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('SO'::text, 'OBJ_URL'::text, OLD.so_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('SO'::text, 'SOURCE_ID'::text, OLD.so_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (OLD.soid != NEW.soid) THEN
        PERFORM nex.insertupdatelog('SO'::text, 'SOID'::text, OLD.so_id, OLD.soid, NEW.soid, USER);
    END IF;

    IF (OLD.is_obsolete != NEW.is_obsolete) THEN
	    PERFORM nex.insertupdatelog('SO'::text, 'IS_OBSOLETE'::text, OLD.so_id, OLD.is_obsolete::text, NEW.is_obsolete::text, USER);
    END IF;

    IF (((OLD.description IS NULL) AND (NEW.description IS NOT NULL)) OR ((OLD.description IS NOT NULL) AND (NEW.description IS NULL)) OR (OLD.description != NEW.description)) THEN
        PERFORM nex.insertupdatelog('SO'::text, 'DESCRIPTION'::text, OLD.so_id, OLD.description, NEW.description, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.so_id || '[:]' || OLD.format_name || '[:]' ||
             OLD.display_name || '[:]' || OLD.obj_url || '[:]' ||
             OLD.source_id || '[:]' || OLD.soid || '[:]' || 
             OLD.is_obsolete || '[:]' || coalesce(OLD.description,'') || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('SO'::text, OLD.so_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER so_audr
AFTER UPDATE OR DELETE ON nex.so FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_so_audr();

DROP TRIGGER IF EXISTS so_biur ON nex.so CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_so_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

      NEW.created_by := UPPER(NEW.created_by);
      PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.so_id != OLD.so_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER so_biur
BEFORE INSERT OR UPDATE ON nex.so FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_so_biur();

DROP TRIGGER IF EXISTS soalias_audr ON nex.so_alias CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_soalias_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('SO_ALIAS'::text, 'DISPLAY_NAME'::text, OLD.alias_id, OLD.display_name, NEW.display_name, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('SO_ALIAS'::text, 'SOURCE_ID'::text, OLD.alias_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (OLD.so_id != NEW.so_id) THEN
        PERFORM nex.insertupdatelog('SO_ALIAS'::text, 'SO_ID'::text, OLD.alias_id, OLD.so_id::text, NEW.so_id::text, USER);
    END IF;

    IF (OLD.alias_type != NEW.alias_type) THEN
        PERFORM nex.insertupdatelog('SO_ALIAS'::text, 'ALIAS_TYPE'::text, OLD.alias_id, OLD.alias_type, NEW.alias_type, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.alias_id || '[:]' || OLD.display_name || '[:]' || 
             OLD.source_id || '[:]' ||
             OLD.so_id || '[:]' || OLD.alias_type || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('SO_ALIAS'::text, OLD.alias_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER soalias_audr
AFTER UPDATE OR DELETE ON nex.so_alias FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_soalias_audr();

DROP TRIGGER IF EXISTS soalias_biur ON nex.so_alias CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_soalias_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

      NEW.created_by := UPPER(NEW.created_by);
      PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;
       
  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.alias_id != OLD.alias_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER soalias_biur
BEFORE INSERT OR UPDATE ON nex.so_alias FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_soalias_biur();

DROP TRIGGER IF EXISTS sorelation_audr ON nex.so_relation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_sorelation_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('SO_RELATION'::text, 'SOURCE_ID'::text, OLD.relation_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (OLD.parent_id != NEW.parent_id) THEN
        PERFORM nex.insertupdatelog('SO_RELATION'::text, 'PARENT_ID'::text, OLD.relation_id, OLD.parent_id::text, NEW.parent_id::text, USER);
    END IF;

     IF (OLD.child_id != NEW.child_id) THEN
        PERFORM nex.insertupdatelog('SO_RELATION'::text, 'CHILD_ID'::text, OLD.relation_id, OLD.child_id::text, NEW.child_id::text, USER);
    END IF;

    IF (OLD.ro_id != NEW.ro_id) THEN
        PERFORM nex.insertupdatelog('SO_RELATION'::text, 'RO_ID'::text, OLD.relation_id, OLD.ro_id::text, NEW.ro_id::text, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.relation_id || '[:]' || OLD.source_id || '[:]' ||
             OLD.parent_id || '[:]' ||
             OLD.child_id || '[:]' || OLD.ro_id || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('SO_RELATION'::text, OLD.relation_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER sorelation_audr
AFTER UPDATE OR DELETE ON nex.so_relation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_sorelation_audr();

DROP TRIGGER IF EXISTS sorelation_biur ON nex.so_relation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_sorelation_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.relation_id != OLD.relation_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER sorelation_biur
BEFORE INSERT OR UPDATE ON nex.so_relation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_sorelation_biur();

DROP TRIGGER IF EXISTS sourl_audr ON nex.so_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_sourl_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('SO_URL'::text, 'DISPLAY_NAME'::text, OLD.url_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('SO_URL'::text, 'OBJ_URL'::text, OLD.url_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('SO_URL'::text, 'SOURCE_ID'::text, OLD.url_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (OLD.so_id != NEW.so_id) THEN
        PERFORM nex.insertupdatelog('SO_URL'::text, 'SO_ID'::text, OLD.url_id, OLD.so_id::text, NEW.so_id::text, USER);
    END IF;

    IF (OLD.url_type != NEW.url_type) THEN
        PERFORM nex.insertupdatelog('SO_URL'::text, 'URL_TYPE'::text, OLD.url_id, OLD.url_type, NEW.url_type, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.url_id || '[:]' || OLD.display_name || '[:]' ||
             OLD.obj_url || '[:]' || OLD.source_id || '[:]' || 
             OLD.so_id || '[:]' || OLD.url_type || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('SO_URL'::text, OLD.url_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER sourl_audr
AFTER UPDATE OR DELETE ON nex.so_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_sourl_audr();

DROP TRIGGER IF EXISTS sourl_biur ON nex.so_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_sourl_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;
       
  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.url_id != OLD.url_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER sourl_biur
BEFORE INSERT OR UPDATE ON nex.so_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_sourl_biur();


DROP TRIGGER IF EXISTS taxonomy_audr ON nex.taxonomy CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_taxonomy_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.format_name != NEW.format_name) THEN
        PERFORM nex.insertupdatelog('TAXONOMY'::text, 'FORMAT_NAME'::text, OLD.taxonomy_id, OLD.format_name, NEW.format_name, USER);
    END IF;

     IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('TAXONOMY'::text, 'DISPLAY_NAME'::text, OLD.taxonomy_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('TAXONOMY'::text, 'OBJ_URL'::text, OLD.taxonomy_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('TAXONOMY'::text, 'SOURCE_ID'::text, OLD.taxonomy_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (OLD.taxid != NEW.taxid) THEN
        PERFORM nex.insertupdatelog('TAXONOMY'::text, 'TAXID'::text, OLD.taxonomy_id, OLD.taxid, NEW.taxid, USER);
    END IF;

    IF (((OLD.common_name IS NULL) AND (NEW.common_name IS NOT NULL)) OR ((OLD.common_name IS NOT NULL) AND (NEW.common_name IS NULL)) OR (OLD.common_name != NEW.common_name)) THEN
        PERFORM nex.insertupdatelog('TAXONOMY'::text, 'COMMON_NAME'::text, OLD.taxonomy_id, OLD.common_name, NEW.common_name, USER);
    END IF;

    IF (OLD.rank != NEW.rank) THEN
        PERFORM nex.insertupdatelog('TAXONOMY'::text, 'RANK'::text, OLD.taxonomy_id, OLD.rank, NEW.rank, USER);
    END IF;

    IF (OLD.is_obsolete != NEW.is_obsolete) THEN
	    PERFORM nex.insertupdatelog('TAXONOMY'::text, 'IS_OBSOLETE'::text, OLD.taxonomy_id, OLD.is_obsolete::text, NEW.is_obsolete::text, USER);
    END IF;

    RETURN NEW;
 
  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.taxonomy_id || '[:]' || OLD.format_name || '[:]' ||
             OLD.display_name || '[:]' || OLD.obj_url || '[:]' ||
             OLD.source_id || '[:]' || OLD.taxid || '[:]' ||
             coalesce(OLD.common_name,'') || '[:]' || OLD.rank || '[:]' ||
             OLD.is_obsolete || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('TAXONOMY'::text, OLD.taxonomy_id, v_row, USER);

    RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER taxonomy_audr
AFTER UPDATE OR DELETE ON nex.taxonomy FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_taxonomy_audr();

DROP TRIGGER IF EXISTS taxonomy_biur ON nex.taxonomy CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_taxonomy_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;
       
  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.taxonomy_id != OLD.taxonomy_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER taxonomy_biur
BEFORE INSERT OR UPDATE ON nex.taxonomy FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_taxonomy_biur();

DROP TRIGGER IF EXISTS taxonomyalias_audr ON nex.taxonomy_alias CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_taxonomyalias_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

     IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('TAXONOMY_ALIAS'::text, 'DISPLAY_NAME'::text, OLD.alias_id, OLD.display_name, NEW.display_name, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('TAXONOMY_ALIAS'::text, 'SOURCE_ID'::text, OLD.alias_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (OLD.taxonomy_id != NEW.taxonomy_id) THEN
        PERFORM nex.insertupdatelog('TAXONOMY_ALIAS'::text, 'TAXONOMY_ID'::text, OLD.alias_id, OLD.taxonomy_id::text, NEW.taxonomy_id::text, USER);
    END IF;

    IF (OLD.alias_type != NEW.alias_type) THEN
        PERFORM nex.insertupdatelog('TAXONOMY_ALIAS'::text, 'ALIAS_TYPE'::text, OLD.alias_id, OLD.alias_type, NEW.alias_type, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.alias_id || '[:]' || OLD.display_name || '[:]' ||
             OLD.source_id || '[:]' || 
             OLD.taxonomy_id || '[:]' || OLD.alias_type || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('TAXONOMY_ALIAS'::text, OLD.alias_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER taxonomyalias_audr
AFTER UPDATE OR DELETE ON nex.taxonomy_alias FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_taxonomyalias_audr();

DROP TRIGGER IF EXISTS taxonomyalias_biur ON nex.taxonomy_alias CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_taxonomyalias_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.alias_id != OLD.alias_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER taxonomyalias_biur
BEFORE INSERT OR UPDATE ON nex.taxonomy_alias FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_taxonomyalias_biur();

DROP TRIGGER IF EXISTS taxonomyrelation_audr ON nex.taxonomy_relation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_taxonomyrelation_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('TAXONOMY_RELATION'::text, 'SOURCE_ID'::text, OLD.relation_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

     IF (OLD.parent_id != NEW.parent_id) THEN
        PERFORM nex.insertupdatelog('TAXONOMY_RELATION'::text, 'PARENT_ID'::text, OLD.relation_id, OLD.parent_id::text, NEW.parent_id::text, USER);
    END IF;

     IF (OLD.child_id != NEW.child_id) THEN
        PERFORM nex.insertupdatelog('TAXONOMY_RELATION'::text, 'CHILD_ID'::text, OLD.relation_id, OLD.child_id::text, NEW.child_id::text, USER);
    END IF;

    IF (OLD.ro_id != NEW.ro_id) THEN
        PERFORM nex.insertupdatelog('TAXONOMY_RELATION'::text, 'RO_ID'::text, OLD.relation_id, OLD.ro_id::text, NEW.ro_id::text, USER);
    END IF;

    RETURN NEW;
    
  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.relation_id || '[:]' || OLD.source_id || '[:]' ||
             OLD.parent_id || '[:]' ||
             OLD.child_id || '[:]' || OLD.ro_id || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('TAXONOMY_RELATION'::text, OLD.relation_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER taxonomyrelation_audr
AFTER UPDATE OR DELETE ON nex.taxonomy_relation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_taxonomyrelation_audr();

DROP TRIGGER IF EXISTS taxonomyrelation_biur ON nex.taxonomy_relation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_taxonomyrelation_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;
       
  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.relation_id != OLD.relation_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER taxonomyrelation_biur
BEFORE INSERT OR UPDATE ON nex.taxonomy_relation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_taxonomyrelation_biur();

DROP TRIGGER IF EXISTS taxonomyurl_audr ON nex.taxonomy_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_taxonomyurl_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

     IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('TAXONOMY_URL'::text, 'DISPLAY_NAME'::text, OLD.url_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('TAXONOMY_URL'::text, 'OBJ_URL'::text, OLD.url_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('TAXONOMY_URL'::text, 'SOURCE_ID'::text, OLD.url_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (OLD.taxonomy_id != NEW.taxonomy_id) THEN
        PERFORM nex.insertupdatelog('TAXONOMY_URL'::text, 'TAXONOMY_ID'::text, OLD.url_id, OLD.taxonomy_id::text, NEW.taxonomy_id::text, USER);
    END IF;

    IF (OLD.url_type != NEW.url_type)  THEN
        PERFORM nex.insertupdatelog('TAXONOMY_URL'::text, 'URL_TYPE'::text, OLD.url_id, OLD.url_type, NEW.url_type, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.url_id || '[:]' ||  OLD.display_name || '[:]' ||
             OLD.obj_url || '[:]' || OLD.source_id || '[:]' || 
             OLD.taxonomy_id || '[:]' || OLD.url_type || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

             PERFORM nex.insertdeletelog('TAXONOMY_URL'::text, OLD.url_id, v_row, USER);

     RETURN OLD;
  END IF;
  
END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER taxonomyurl_audr
AFTER UPDATE OR DELETE ON nex.taxonomy_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_taxonomyurl_audr();

DROP TRIGGER IF EXISTS taxonomyurl_biur ON nex.taxonomy_url CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_taxonomyurl_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

      NEW.created_by := UPPER(NEW.created_by);
      PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.url_id != OLD.url_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$  LANGUAGE 'plpgsql';

CREATE TRIGGER taxonomyurl_biur
BEFORE INSERT OR UPDATE ON nex.taxonomy_url FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_taxonomyurl_biur();
