-- Generated by Ora2Pg, the Oracle database Schema converter, version 17.4
-- Copyright 2000-2016 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=sgd-nex2-db.stanford.edu;sid=SGD

SET client_encoding TO 'UTF8';

\set ON_ERROR_STOP ON


DROP TRIGGER IF EXISTS bindingmotifannotation_audr ON nex.bindingmotifannotation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_bindingmotifannotation_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.dbentity_id != NEW.dbentity_id) THEN
        PERFORM nex.insertupdatelog('BINDINGMOTIFANNOTATION'::text, 'DBENTITY_ID'::text, OLD.annotation_id, OLD.dbentity_id::text, NEW.dbentity_id::text, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('BINDINGMOTIFANNOTATION'::text, 'SOURCE_ID'::text, OLD.annotation_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (OLD.taxonomy_id != NEW.taxonomy_id) THEN
        PERFORM nex.insertupdatelog('BINDINGMOTIFANNOTATION'::text, 'TAXONOMY_ID'::text, OLD.annotation_id, OLD.taxonomy_id::text, NEW.taxonomy_id::text, USER);
    END IF;

    IF  (((OLD.reference_id IS NULL) AND (NEW.reference_id IS NOT NULL)) OR ((OLD.reference_id IS NOT NULL) AND (NEW.reference_id IS NULL)) OR (OLD.reference_id != NEW.reference_id)) THEN
        PERFORM nex.insertupdatelog('BINDINGMOTIFANNOTATION'::text, 'REFERENCE_ID'::text, OLD.annotation_id, OLD.reference_id::text, NEW.reference_id::text, USER);
    END IF;

    IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('BINDINGMOTIFANNOTATION'::text, 'OBJ_URL'::text, OLD.annotation_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

    IF (OLD.motif_id != NEW.motif_id) THEN
        PERFORM nex.insertupdatelog('BINDINGMOTIFANNOTATION'::text, 'MOTIF_ID'::text, OLD.annotation_id, OLD.motif_id::text, NEW.motif_id::text, USER);
    END IF;

    IF (OLD.logo_url != NEW.logo_url)
    THEN
        PERFORM nex.insertupdatelog('BINDINGMOTIFANNOTATION'::text, 'LOGO_URL'::text, OLD.annotation_id, OLD.logo_url, NEW.logo_url, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.annotation_id || '[:]' || OLD.dbentity_id || '[:]' ||
             OLD.source_id || '[:]' || OLD.taxonomy_id || '[:]' ||
             coalesce(OLD.reference_id,0) || '[:]' || OLD.obj_url || '[:]' ||
             OLD.motif_id || '[:]' || OLD.logo_url || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

           PERFORM nex.insertdeletelog('BINDINGMOTIFANNOTATION'::text, OLD.annotation_id, v_row, USER);

    RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER bindingmotifannotation_audr
AFTER UPDATE OR DELETE ON nex.bindingmotifannotation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_bindingmotifannotation_audr();

DROP TRIGGER IF EXISTS bindingmotifannotation_biur ON nex.bindingmotifannotation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_bindingmotifannotation_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.annotation_id != OLD.annotation_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER bindingmotifannotation_biur
BEFORE INSERT OR UPDATE ON nex.bindingmotifannotation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_bindingmotifannotation_biur();


DROP TRIGGER IF EXISTS complexbindingannotation_audr ON nex.complexbindingannotation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_complexbindingannotation_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.complex_id != NEW.complex_id) THEN
        PERFORM nex.insertupdatelog('COMPLEXBINDINGANNOTATION'::text, 'COMPLEX_ID'::text, OLD.annotation_id, OLD.complex_id::text, NEW.complex_id::text, USER);
    END IF;

    IF (OLD.interactor_id != NEW.interactor_id) THEN
        PERFORM nex.insertupdatelog('COMPLEXBINDINGANNOTATION'::text, 'INTERACTOR_ID'::text, OLD.annotation_id, OLD.interactor_id::text, NEW.interactor_id::text, USER);
    END IF;

    IF (OLD.binding_interactor_id != NEW.binding_interactor_id) THEN
        PERFORM nex.insertupdatelog('COMPLEXBINDINGANNOTATION'::text, 'BINDING_INTERACTOR_ID'::text, OLD.annotation_id, OLD.binding_interactor_id::text, NEW.binding_interactor_id::text, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('COMPLEXBINDINGANNOTATION'::text, 'SOURCE_ID'::text, OLD.annotation_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (OLD.taxonomy_id != NEW.taxonomy_id) THEN
        PERFORM nex.insertupdatelog('COMPLEXBINDINGANNOTATION'::text, 'TAXONOMY_ID'::text, OLD.annotation_id, OLD.taxonomy_id::text, NEW.taxonomy_id::text, USER);
    END IF;

    IF (((OLD.reference_id IS NULL) AND (NEW.reference_id IS NOT NULL)) OR ((OLD.reference_id IS NOT NULL) AND (NEW.reference_id IS NULL)) OR (OLD.reference_id != NEW.reference_id)) THEN
       PERFORM nex.insertupdatelog('COMPLEXBINDINGANNOTATION'::text, 'REFERENCE_ID'::text, OLD.interactor_id, OLD.reference_id::text, NEW.reference_id::text, USER);
    END IF;

    IF (OLD.binding_type_id != NEW.binding_type_id) THEN
        PERFORM nex.insertupdatelog('COMPLEXBINDINGANNOTATION'::text, 'BINDING_TYPE_ID'::text, OLD.annotation_id, OLD.binding_type_id::text, NEW.binding_type_id::text, USER);
    END IF;

    IF (((OLD.stoichiometry IS NULL) AND (NEW.stoichiometry IS NOT NULL)) OR ((OLD.stoichiometry IS NOT NULL) AND (NEW.stoichiometry IS NULL)) OR (OLD.stoichiometry != NEW.stoichiometry)) THEN
       PERFORM nex.insertupdatelog('COMPLEXBINDINGANNOTATION'::text, 'STOICHIOMETRY'::text, OLD.annotation_id, OLD.stoichiometry::text, NEW.stoichiometry::text, USER);
    END IF;

    IF (((OLD.range_start IS NULL) AND (NEW.range_start IS NOT NULL)) OR ((OLD.range_start IS NOT NULL) AND (NEW.range_start IS NULL)) OR (OLD.range_start != NEW.range_start)) THEN
       PERFORM nex.insertupdatelog('COMPLEXBINDINGANNOTATION'::text, 'RANGE_START'::text, OLD.annotation_id, OLD.range_start::text, NEW.range_start::text, USER);
    END IF;

    IF (((OLD.range_end IS NULL) AND (NEW.range_end IS NOT NULL)) OR ((OLD.range_end IS NOT NULL) AND (NEW.range_end IS NULL)) OR (OLD.range_end != NEW.range_end)) THEN
       PERFORM nex.insertupdatelog('COMPLEXBINDINGANNOTATION'::text, 'RANGE_END'::text, OLD.annotation_id, OLD.range_end::text, NEW.range_end::text, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.annotation_id || '[:]' || OLD.complex_id || '[:]' ||
             OLD.interactor_id || '[:]' || OLD.binding_interactor_id || '[:]' ||
             OLD.source_id || '[:]' || coalesce(OLD.reference_id,0) || '[:]' ||
             OLD.taxonomy_id || '[:]' || OLD.binding_type_id || '[:]' ||
             coalesce(OLD.stoichiometry,0) || '[:]' || 
             coalesce(OLD.range_start,0) || '[:]' || coalesce(OLD.range_end,0) || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

           PERFORM nex.insertdeletelog('COMPLEXBINDINGANNOTATION'::text, OLD.annotation_id, v_row, USER);

    RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER complexbindingannotation_audr
AFTER UPDATE OR DELETE ON nex.complexbindingannotation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_complexbindingannotation_audr();


DROP TRIGGER IF EXISTS complexbindingannotation_biur ON nex.complexbindingannotation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_complexbindingannotation_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.annotation_id != OLD.annotation_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER complexbindingannotation_biur
BEFORE INSERT OR UPDATE ON nex.complexbindingannotation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_complexbindingannotation_biur();


DROP TRIGGER IF EXISTS diseaseannotation_audr ON nex.diseaseannotation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_diseaseannotation_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.dbentity_id != NEW.dbentity_id) THEN
        PERFORM nex.insertupdatelog('DISEASEANNOTATION'::text, 'DBENTITY_ID'::text, OLD.annotation_id, OLD.dbentity_id::text, NEW.dbentity_id::text, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('DISEASEANNOTATION'::text, 'SOURCE_ID'::text, OLD.annotation_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

     IF (OLD.taxonomy_id != NEW.taxonomy_id) THEN
        PERFORM nex.insertupdatelog('DISEASEANNOTATION'::text, 'TAXONOMY_ID'::text, OLD.annotation_id, OLD.taxonomy_id::text, NEW.taxonomy_id::text, USER);
    END IF;

    IF (OLD.reference_id != NEW.reference_id) THEN
        PERFORM nex.insertupdatelog('DISEASEANNOTATION'::text, 'REFERENCE_ID'::text, OLD.annotation_id, OLD.reference_id::text, NEW.reference_id::text, USER);
    END IF;

    IF (OLD.disease_id != NEW.disease_id) THEN
        PERFORM nex.insertupdatelog('DISEASEANNOTATION'::text, 'DISEASE_ID'::text, OLD.annotation_id, OLD.disease_id::text, NEW.disease_id::text, USER);
    END IF;

    IF (OLD.eco_id != NEW.eco_id) THEN
        PERFORM nex.insertupdatelog('DISEASEANNOTATION'::text, 'ECO_ID'::text, OLD.annotation_id, OLD.eco_id::text, NEW.eco_id::text, USER);
    END IF;

    IF (OLD.association_type != NEW.association_type) THEN
        PERFORM nex.insertupdatelog('DISEASEANNOTATION'::text, 'ASSOCIATION_TYPE'::text, OLD.annotation_id, OLD.association_type::text, NEW.association_type::text, USER);
    END IF;

    IF (OLD.annotation_type != NEW.annotation_type) THEN
        PERFORM nex.insertupdatelog('DISEASEANNOTATION'::text, 'ANNOTATION_TYPE'::text, OLD.annotation_id, OLD.annotation_type, NEW.annotation_type, USER);
    END IF;

    IF  (((OLD.disease_qualifier IS NULL) AND (NEW.disease_qualifier IS NOT NULL)) OR ((OLD.disease_qualifier IS NOT NULL) AND (NEW.disease_qualifier IS NULL)) OR (OLD.disease_qualifier != NEW.disease_qualifier)) THEN
        PERFORM nex.insertupdatelog('DISEASEANNOTATION'::text, 'DISEASE_QUALIFIER'::text, OLD.annotation_id, OLD.disease_qualifier::text, NEW.disease_qualifier::text, USER);
    END IF;

    IF (OLD.date_assigned != NEW.date_assigned) THEN
        PERFORM nex.insertupdatelog('DISEASEANNOTATION'::text, 'DATE_ASSIGNED'::text, OLD.annotation_id, OLD.date_assigned::text, NEW.date_assigned::text, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.annotation_id || '[:]' || OLD.dbentity_id || '[:]' ||
             OLD.source_id || '[:]' || OLD.taxonomy_id || '[:]' ||
             OLD.reference_id || '[:]' || OLD.disease_id || '[:]' ||
             OLD.eco_id || '[:]' || OLD.association_type || '[:]' ||
             OLD.annotation_type || '[:]' ||
             coalesce(OLD.disease_qualifier,'') || '[:]' || OLD.date_assigned || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

           PERFORM nex.insertdeletelog('DISEASEANNOTATION'::text, OLD.annotation_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER diseaseannotation_audr
AFTER UPDATE OR DELETE ON nex.diseaseannotation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_diseaseannotation_audr();

DROP TRIGGER IF EXISTS diseaseannotation_biur ON nex.diseaseannotation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_diseaseannotation_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.annotation_id != OLD.annotation_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER diseaseannotation_biur
BEFORE INSERT OR UPDATE ON nex.diseaseannotation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_diseaseannotation_biur();

DROP TRIGGER IF EXISTS diseasesubsetannotation_audr ON nex.diseasesubsetannotation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_diseasesubsetannotation_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.dbentity_id != NEW.dbentity_id) THEN
        PERFORM nex.insertupdatelog('DISEASESUBSETANNOTATION'::text, 'DBENTITY_ID'::text, OLD.annotation_id, OLD.dbentity_id::text, NEW.dbentity_id::text, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('DISEASESUBSETANNOTATION'::text, 'SOURCE_ID'::text, OLD.annotation_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (OLD.taxonomy_id != NEW.taxonomy_id) THEN
        PERFORM nex.insertupdatelog('DISEASESUBSETANNOTATION'::text, 'TAXONOMY_ID'::text, OLD.annotation_id, OLD.taxonomy_id::text, NEW.taxonomy_id::text, USER);
    END IF;

    IF (((OLD.reference_id IS NULL) AND (NEW.reference_id IS NOT NULL)) OR ((OLD.reference_id IS NOT NULL) AND (NEW.reference_id IS NULL)) OR (OLD.reference_id != NEW.reference_id)) THEN
        PERFORM nex.insertupdatelog('DISEASESUBSETANNOTATION'::text, 'REFERENCE_ID'::text, OLD.annotation_id, OLD.reference_id::text, NEW.reference_id::text, USER);
    END IF;

    IF (OLD.diseasesubset_id != NEW.diseasesubset_id) THEN
        PERFORM nex.insertupdatelog('DISEASESUBSETANNOTATION'::text, 'DISEASESUBSET_ID'::text, OLD.annotation_id, OLD.diseasesubset_id::text, NEW.diseasesubset_id::text, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.annotation_id || '[:]' || OLD.dbentity_id || '[:]' ||
             OLD.source_id || '[:]' || OLD.taxonomy_id || '[:]' ||
             coalesce(OLD.reference_id,0) || '[:]' || OLD.diseasesubset_id || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

        PERFORM nex.insertdeletelog('DISEASESUBSETANNOTATION'::text, OLD.annotation_id, v_row, USER);

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER diseasesubsetannotation_audr
AFTER UPDATE OR DELETE ON nex.diseasesubsetannotation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_diseasesubsetannotation_audr();

DROP TRIGGER IF EXISTS diseasesubsetannotation_biur ON nex.diseasesubsetannotation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_diseasesubsetannotation_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.annotation_id != OLD.annotation_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER diseasesubsetannotation_biur
BEFORE INSERT OR UPDATE ON nex.diseasesubsetannotation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_diseasesubsetannotation_biur();

DROP TRIGGER IF EXISTS diseasesupportingevidence_audr ON nex.diseasesupportingevidence CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_diseasesupportingevidence_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.annotation_id != NEW.annotation_id) THEN
        PERFORM nex.insertupdatelog('DISEASESUPPORTINGEVIDENCE'::text, 'ANNOTATION_ID'::text, OLD.diseasesupportingevidence_id, OLD.annotation_id::text, NEW.annotation_id::text, USER);
    END IF;

     IF (OLD.group_id != NEW.group_id) THEN
        PERFORM nex.insertupdatelog('DISEASESUPPORTINGEVIDENCE'::text, 'GROUP_ID'::text, OLD.diseasesupportingevidence_id, OLD.group_id::text, NEW.group_id::text, USER);
    END IF;

     IF (OLD.dbxref_id != NEW.dbxref_id) THEN
        PERFORM nex.insertupdatelog('DISEASESUPPORTINGEVIDENCE'::text, 'DBXREF_ID'::text, OLD.diseasesupportingevidence_id, OLD.dbxref_id, NEW.dbxref_id, USER);
    END IF;

     IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('DISEASESUPPORTINGEVIDENCE'::text, 'OBJ_URL'::text, OLD.diseasesupportingevidence_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.evidence_type != NEW.evidence_type) THEN
        PERFORM nex.insertupdatelog('DISEASESUPPORTINGEVIDENCE'::text, 'EVIDENCE_TYPE'::text, OLD.diseasesupportingevidence_id, OLD.evidence_type, NEW.evidence_type, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.diseasesupportingevidence_id || '[:]' || OLD.annotation_id || '[:]' ||
             OLD.group_id || '[:]' || OLD.dbxref_id || '[:]' ||
             OLD.obj_url || '[:]' || OLD.evidence_type || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

         PERFORM nex.insertdeletelog('DISEASESUPPORTINGEVIDENCE'::text, OLD.diseasesupportingevidence_id, v_row, USER);

    RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER diseasesupportingevidence_audr
AFTER UPDATE OR DELETE ON nex.diseasesupportingevidence FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_diseasesupportingevidence_audr();

DROP TRIGGER IF EXISTS diseasesupportingevidence_biur ON nex.diseasesupportingevidence CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_diseasesupportingevidence_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.diseasesupportingevidence_id != OLD.diseasesupportingevidence_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER diseasesupportingevidence_biur
BEFORE INSERT OR UPDATE ON nex.diseasesupportingevidence FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_diseasesupportingevidence_biur();


DROP TRIGGER IF EXISTS dnasequenceannotation_audr ON nex.dnasequenceannotation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_dnasequenceannotation_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.dbentity_id != NEW.dbentity_id) THEN
        PERFORM nex.insertupdatelog('DNASEQUENCEANNOTATION'::text, 'DBENTITY_ID'::text, OLD.annotation_id, OLD.dbentity_id::text, NEW.dbentity_id::text, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('DNASEQUENCEANNOTATION'::text, 'SOURCE_ID'::text, OLD.annotation_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

     IF (OLD.taxonomy_id != NEW.taxonomy_id) THEN
        PERFORM nex.insertupdatelog('DNASEQUENCEANNOTATION'::text, 'TAXONOMY_ID'::text, OLD.annotation_id, OLD.taxonomy_id::text, NEW.taxonomy_id::text, USER);
    END IF;

    IF (((OLD.reference_id IS NULL) AND (NEW.reference_id IS NOT NULL)) OR ((OLD.reference_id IS NOT NULL) AND (NEW.reference_id IS NULL)) OR (OLD.reference_id != NEW.reference_id)) THEN
        PERFORM nex.insertupdatelog('DNASEQUENCEANNOTATION'::text, 'REFERENCE_ID'::text, OLD.annotation_id, OLD.reference_id::text, NEW.reference_id::text, USER);
    END IF;

    IF (((OLD.bud_id IS NULL) AND (NEW.bud_id IS NOT NULL)) OR ((OLD.bud_id IS NOT NULL) AND (NEW.bud_id IS NULL)) OR (OLD.bud_id != NEW.bud_id)) THEN
        PERFORM nex.insertupdatelog('DNASEQUENCEANNOTATION'::text, 'BUD_ID'::text, OLD.annotation_id, OLD.bud_id::text, NEW.bud_id::text, USER);
    END IF;

     IF (OLD.so_id != NEW.so_id) THEN
        PERFORM nex.insertupdatelog('DNASEQUENCEANNOTATION'::text, 'SO_ID'::text, OLD.annotation_id, OLD.so_id::text, NEW.so_id::text, USER);
    END IF;

    IF (OLD.dna_type != NEW.dna_type) THEN
        PERFORM nex.insertupdatelog('DNASEQUENCEANNOTATION'::text, 'DNA_TYPE'::text, OLD.annotation_id, OLD.dna_type, NEW.dna_type, USER);
    END IF;

    IF (OLD.contig_id != NEW.contig_id) THEN
        PERFORM nex.insertupdatelog('DNASEQUENCEANNOTATION'::text, 'CONTIG_ID'::text, OLD.annotation_id, OLD.contig_id::text, NEW.contig_id::text, USER);
    END IF;

    IF (((OLD.seq_version IS NULL) AND (NEW.seq_version IS NOT NULL)) OR ((OLD.seq_version IS NOT NULL) AND (NEW.seq_version IS NULL)) OR (OLD.seq_version != NEW.seq_version)) THEN
        PERFORM nex.insertupdatelog('DNASEQUENCEANNOTATION'::text, 'SEQ_VERSION'::text, OLD.annotation_id, OLD.seq_version::text, NEW.seq_version::text, USER);
    END IF;

    IF (((OLD.coord_version IS NULL) AND (NEW.coord_version IS NOT NULL)) OR ((OLD.coord_version IS NOT NULL) AND (NEW.coord_version IS NULL)) OR (OLD.coord_version != NEW.coord_version)) THEN
        PERFORM nex.insertupdatelog('DNASEQUENCEANNOTATION'::text, 'COORD_VERSION'::text, OLD.annotation_id, OLD.coord_version::text, NEW.coord_version::text, USER);
    END IF;

    IF (((OLD.genomerelease_id IS NULL) AND (NEW.genomerelease_id IS NOT NULL)) OR ((OLD.genomerelease_id IS NOT NULL) AND (NEW.genomerelease_id IS NULL)) OR (OLD.genomerelease_id != NEW.genomerelease_id)) THEN
        PERFORM nex.insertupdatelog('DNASEQUENCEANNOTATION'::text, 'GENOMERELEASE_ID'::text, OLD.annotation_id, OLD.genomerelease_id::text, NEW.genomerelease_id::text, USER);
    END IF;

    IF (OLD.start_index != NEW.start_index) THEN
        PERFORM nex.insertupdatelog('DNASEQUENCEANNOTATION'::text, 'START_INDEX'::text, OLD.annotation_id, OLD.start_index::text, NEW.start_index::text, USER);
    END IF;

    IF (OLD.end_index != NEW.end_index) THEN
        PERFORM nex.insertupdatelog('DNASEQUENCEANNOTATION'::text, 'END_INDEX'::text, OLD.annotation_id, OLD.end_index::text, NEW.end_index::text, USER);
    END IF;

    IF (OLD.strand != NEW.strand) THEN
        PERFORM nex.insertupdatelog('DNASEQUENCEANNOTATION'::text, 'STRAND'::text, OLD.annotation_id, OLD.strand, NEW.strand, USER);
    END IF;

    IF (OLD.file_header != NEW.file_header) THEN
        PERFORM nex.insertupdatelog('DNASEQUENCEANNOTATION'::text, 'FILE_HEADER'::text, OLD.annotation_id, OLD.file_header, NEW.file_header, USER);
    END IF;

    IF (OLD.download_filename != NEW.download_filename)
    THEN
        PERFORM nex.insertupdatelog('DNASEQUENCEANNOTATION'::text, 'DOWNLOAD_FILENAME'::text, OLD.annotation_id, OLD.download_filename, NEW.download_filename, USER);
    END IF;

    IF (((OLD.file_id IS NULL) AND (NEW.file_id IS NOT NULL)) OR ((OLD.file_id IS NOT NULL) AND (NEW.file_id IS NULL)) OR (OLD.file_id != NEW.file_id)) THEN
        PERFORM nex.insertupdatelog('DNASEQUENCEANNOTATION'::text, 'FILE_ID'::text, OLD.annotation_id, OLD.file_id::text, NEW.file_id::text, USER);
    END IF;

     IF (OLD.residues != NEW.residues) THEN
        PERFORM nex.insertupdatelog('DNASEQUENCEANNOTATION'::text, 'RESIDUES'::text, OLD.annotation_id, OLD.residues, NEW.residues, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.annotation_id || '[:]' || OLD.dbentity_id || '[:]' ||
             OLD.source_id || '[:]' || OLD.taxonomy_id || '[:]' ||
             coalesce(OLD.reference_id,0) || '[:]' || coalesce(OLD.bud_id,0) || '[:]' ||
             OLD.so_id || '[:]' || OLD.dna_type || '[:]' ||
             OLD.contig_id || '[:]' || coalesce(OLD.seq_version,'') || '[:]' ||
             coalesce(OLD.coord_version,'') || '[:]' || coalesce(OLD.genomerelease_id,'') || '[:]' ||
             OLD.start_index || '[:]' || OLD.end_index || '[:]' ||
             OLD.strand || '[:]' ||
             OLD.file_header || '[:]' || OLD.download_filename || '[:]' ||
             coalesce(OLD.file_id,0) || '[:]' || OLD.residues || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

           PERFORM nex.insertdeletelog('DNASEQUENCEANNOTATION'::text, OLD.annotation_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER dnasequenceannotation_audr
AFTER UPDATE OR DELETE ON nex.dnasequenceannotation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_dnasequenceannotation_audr();

DROP TRIGGER IF EXISTS dnasequenceannotation_biur ON nex.dnasequenceannotation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_dnasequenceannotation_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.annotation_id != OLD.annotation_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER dnasequenceannotation_biur
BEFORE INSERT OR UPDATE ON nex.dnasequenceannotation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_dnasequenceannotation_biur();



DROP TRIGGER IF EXISTS dnasubsequence_audr ON nex.dnasubsequence CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_dnasubsequence_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.annotation_id != NEW.annotation_id) THEN
        PERFORM nex.insertupdatelog('DNASUBSEQUENCE'::text, 'ANNOTATION_ID'::text, OLD.dnasubsequence_id, OLD.annotation_id::text, NEW.annotation_id::text, USER);
    END IF;

    IF (OLD.dbentity_id != NEW.dbentity_id) THEN
        PERFORM nex.insertupdatelog('DNASUBSEQUENCE'::text, 'DBENTITY_ID'::text, OLD.dnasubsequence_id, OLD.dbentity_id::text, NEW.dbentity_id::text, USER);
    END IF;

     IF (OLD.display_name != NEW.display_name) THEN
        PERFORM nex.insertupdatelog('DNASUBSEQUENCE'::text, 'DISPLAY_NAME'::text, OLD.dnasubsequence_id, OLD.display_name, NEW.display_name, USER);
    END IF;

    IF (((OLD.bud_id IS NULL) AND (NEW.bud_id IS NOT NULL)) OR ((OLD.bud_id IS NOT NULL) AND (NEW.bud_id IS NULL)) OR (OLD.bud_id != NEW.bud_id)) THEN
        PERFORM nex.insertupdatelog('DNASUBSEQUENCE'::text, 'BUD_ID'::text, OLD.dnasubsequence_id, OLD.bud_id::text, NEW.bud_id::text, USER);
    END IF;

     IF (OLD.so_id != NEW.so_id) THEN
        PERFORM nex.insertupdatelog('DNASUBSEQUENCE'::text, 'SO_ID'::text, OLD.dnasubsequence_id, OLD.so_id::text, NEW.so_id::text, USER);
    END IF;

    IF (OLD.relative_start_index != NEW.relative_start_index) THEN
        PERFORM nex.insertupdatelog('DNASUBSEQUENCE'::text, 'RELATIVE_START_INDEX'::text, OLD.dnasubsequence_id, OLD.relative_start_index::text, NEW.relative_start_index::text, USER);
    END IF;

    IF (OLD.relative_end_index != NEW.relative_end_index) THEN
        PERFORM nex.insertupdatelog('DNASUBSEQUENCE'::text, 'RELATIVE_END_INDEX'::text, OLD.dnasubsequence_id, OLD.relative_end_index::text, NEW.relative_end_index::text, USER);
    END IF;

    IF (OLD.contig_start_index != NEW.contig_start_index) THEN
        PERFORM nex.insertupdatelog('DNASUBSEQUENCE'::text, 'CONTIG_START_INDEX'::text, OLD.dnasubsequence_id, OLD.contig_start_index::text, NEW.contig_start_index::text, USER);
    END IF;

    IF (OLD.contig_end_index != NEW.contig_end_index) THEN
        PERFORM nex.insertupdatelog('DNASUBSEQUENCE'::text, 'CONTIG_END_INDEX'::text, OLD.dnasubsequence_id, OLD.contig_end_index::text, NEW.contig_end_index::text, USER);
    END IF;

    IF (((OLD.seq_version IS NULL) AND (NEW.seq_version IS NOT NULL)) OR ((OLD.seq_version IS NOT NULL) AND (NEW.seq_version IS NULL)) OR (OLD.seq_version != NEW.seq_version)) THEN
        PERFORM nex.insertupdatelog('DNASUBSEQUENCE'::text, 'SEQ_VERSION'::text, OLD.dnasubsequence_id, OLD.seq_version::text, NEW.seq_version::text, USER);
    END IF;

    IF (((OLD.coord_version IS NULL) AND (NEW.coord_version IS NOT NULL)) OR ((OLD.coord_version IS NOT NULL) AND (NEW.coord_version IS NULL)) OR (OLD.coord_version != NEW.coord_version)) THEN
        PERFORM nex.insertupdatelog('DNASUBSEQUENCE'::text, 'COORD_VERSION'::text, OLD.dnasubsequence_id, OLD.coord_version::text, NEW.coord_version::text, USER);
    END IF;

    IF (((OLD.genomerelease_id IS NULL) AND (NEW.genomerelease_id IS NOT NULL)) OR ((OLD.genomerelease_id IS NOT NULL) AND (NEW.genomerelease_id IS NULL)) OR (OLD.genomerelease_id != NEW.genomerelease_id)) THEN
        PERFORM nex.insertupdatelog('DNASUBSEQUENCE'::text, 'GENOMERELEASE_ID'::text, OLD.dnasubsequence_id, OLD.genomerelease_id::text, NEW.genomerelease_id::text, USER);
    END IF;
    
    IF (OLD.file_header != NEW.file_header) THEN
        PERFORM nex.insertupdatelog('DNASUBSEQUENCE'::text, 'FILE_HEADER'::text, OLD.dnasubsequence_id, OLD.file_header, NEW.file_header, USER);
    END IF;

    IF (OLD.download_filename != NEW.download_filename)
    THEN
        PERFORM nex.insertupdatelog('DNASUBSEQUENCE'::text, 'DOWNLOAD_FILENAME'::text, OLD.dnasubsequence_id, OLD.download_filename, NEW.download_filename, USER);
    END IF;

    IF (((OLD.file_id IS NULL) AND (NEW.file_id IS NOT NULL)) OR ((OLD.file_id IS NOT NULL) AND (NEW.file_id IS NULL)) OR (OLD.file_id != NEW.file_id)) THEN
        PERFORM nex.insertupdatelog('DNASUBSEQUENCE'::text, 'FILE_ID'::text, OLD.dnasubsequence_id, OLD.file_id::text, NEW.file_id::text, USER);
    END IF;

     IF (OLD.residues != NEW.residues) THEN
        PERFORM nex.insertupdatelog('DNASUBSEQUENCE'::text, 'RESIDUES'::text, OLD.dnasubsequence_id, OLD.residues, NEW.residues, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.dnasubsequence_id || '[:]' || OLD.annotation_id || '[:]' ||
             OLD.dbentity_id || '[:]' || OLD.display_name || '[:]' || 
             coalesce(OLD.bud_id,0) || '[:]' || OLD.so_id || '[:]' ||
             OLD.relative_start_index || '[:]' || OLD.relative_end_index || '[:]' ||
             OLD.contig_start_index || '[:]' || OLD.contig_end_index || '[:]' ||
             coalesce(OLD.seq_version,'') || '[:]' || coalesce(OLD.coord_version,'') || '[:]' ||
             coalesce(OLD.genomerelease_id,'') || '[:]' || OLD.file_header || '[:]' ||
             OLD.download_filename || '[:]' || coalesce(OLD.file_id,0) || '[:]' ||
             OLD.residues || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

           PERFORM nex.insertdeletelog('DNASUBSEQUENCE'::text, OLD.dnasubsequence_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER dnasubsequence_audr
AFTER UPDATE OR DELETE ON nex.dnasubsequence FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_dnasubsequence_audr();

DROP TRIGGER IF EXISTS dnasubsequence_biur ON nex.dnasubsequence CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_dnasubsequence_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.dnasubsequence_id != OLD.dnasubsequence_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER dnasubsequence_biur
BEFORE INSERT OR UPDATE ON nex.dnasubsequence FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_dnasubsequence_biur();


DROP TRIGGER IF EXISTS enzymeannotation_audr ON nex.enzymeannotation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_enzymeannotation_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.dbentity_id != NEW.dbentity_id) THEN
        PERFORM nex.insertupdatelog('ENZYMEANNOTATION'::text, 'DBENTITY_ID'::text, OLD.annotation_id, OLD.dbentity_id::text, NEW.dbentity_id::text, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('ENZYMEANNOTATION'::text, 'SOURCE_ID'::text, OLD.annotation_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (OLD.taxonomy_id != NEW.taxonomy_id) THEN
        PERFORM nex.insertupdatelog('ENZYMEANNOTATION'::text, 'TAXONOMY_ID'::text, OLD.annotation_id, OLD.taxonomy_id::text, NEW.taxonomy_id::text, USER);
    END IF;

    IF  (((OLD.reference_id IS NULL) AND (NEW.reference_id IS NOT NULL)) OR ((OLD.reference_id IS NOT NULL) AND (NEW.reference_id IS NULL)) OR (OLD.reference_id != NEW.reference_id)) THEN
        PERFORM nex.insertupdatelog('ENZYMEANNOTATION'::text, 'REFERENCE_ID'::text, OLD.annotation_id, OLD.reference_id::text, NEW.reference_id::text, USER);
    END IF;

    IF (OLD.ec_id != NEW.ec_id) THEN
        PERFORM nex.insertupdatelog('ENZYMEANNOTATION'::text, 'EC_ID'::text, OLD.annotation_id, OLD.ec_id::text, NEW.ec_id::text, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.annotation_id || '[:]' || OLD.dbentity_id || '[:]' ||
             OLD.source_id || '[:]' || OLD.taxonomy_id || '[:]' ||
             coalesce(OLD.reference_id,0) || '[:]' ||  OLD.ec_id || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

         PERFORM nex.insertdeletelog('ENZYMEANNOTATION'::text, OLD.annotation_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER enzymeannotation_audr
AFTER UPDATE OR DELETE ON nex.enzymeannotation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_enzymeannotation_audr();

DROP TRIGGER IF EXISTS enzymeannotation_biur ON nex.enzymeannotation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_enzymeannotation_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;
       
  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.annotation_id != OLD.annotation_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER enzymeannotation_biur
BEFORE INSERT OR UPDATE ON nex.enzymeannotation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_enzymeannotation_biur();


DROP TRIGGER IF EXISTS expressionannotation_audr ON nex.expressionannotation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_expressionannotation_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.dbentity_id != NEW.dbentity_id) THEN
        PERFORM nex.insertupdatelog('EXPRESSIONANNOTATION'::text, 'DBENTITY_ID'::text, OLD.annotation_id, OLD.dbentity_id::text, NEW.dbentity_id::text, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('EXPRESSIONANNOTATION'::text, 'SOURCE_ID'::text, OLD.annotation_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (OLD.taxonomy_id != NEW.taxonomy_id) THEN
        PERFORM nex.insertupdatelog('EXPRESSIONANNOTATION'::text, 'TAXONOMY_ID'::text, OLD.annotation_id, OLD.taxonomy_id::text, NEW.taxonomy_id::text, USER);
    END IF;

    IF  (((OLD.reference_id IS NULL) AND (NEW.reference_id IS NOT NULL)) OR ((OLD.reference_id IS NOT NULL) AND (NEW.reference_id IS NULL)) OR (OLD.reference_id != NEW.reference_id)) THEN
        PERFORM nex.insertupdatelog('EXPRESSIONANNOTATION'::text, 'REFERENCE_ID'::text, OLD.annotation_id, OLD.reference_id::text, NEW.reference_id::text, USER);
    END IF;

    IF (OLD.datasetsample_id != NEW.datasetsample_id) THEN
        PERFORM nex.insertupdatelog('EXPRESSIONANNOTATION'::text, 'DATASETSAMPLE_ID'::text, OLD.annotation_id, OLD.datasetsample_id::text, NEW.datasetsample_id::text, USER);
    END IF;

    IF (OLD.normalized_expression_value != NEW.normalized_expression_value) THEN
        PERFORM nex.insertupdatelog('EXPRESSIONANNOTATION'::text, 'NORMALIZED_EXPRESSION_VALUE'::text, OLD.annotation_id, OLD.normalized_expression_value::text, NEW.normalized_expression_value::text, USER);
    END IF;

    IF (OLD.log_ratio_value != NEW.log_ratio_value) THEN
        PERFORM nex.insertupdatelog('EXPRESSIONANNOTATION'::text, 'LOG_RATIO_VALUE'::text, OLD.annotation_id, OLD.log_ratio_value::text, NEW.log_ratio_value::text, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.annotation_id || '[:]' || OLD.dbentity_id || '[:]' ||
             OLD.source_id || '[:]' || OLD.taxonomy_id || '[:]' ||
             coalesce(OLD.reference_id,0) || '[:]' || 
             OLD.datasetsample_id || '[:]' || OLD.normalized_expression_value || '[:]' ||
             OLD.log_ratio_value || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

            PERFORM nex.insertdeletelog('EXPRESSIONANNOTATION'::text, OLD.annotation_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER expressionannotation_audr
AFTER UPDATE OR DELETE ON nex.expressionannotation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_expressionannotation_audr();

DROP TRIGGER IF EXISTS expressionannotation_biur ON nex.expressionannotation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_expressionannotation_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.annotation_id != OLD.annotation_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER expressionannotation_biur
BEFORE INSERT OR UPDATE ON nex.expressionannotation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_expressionannotation_biur();


DROP TRIGGER IF EXISTS geninteractionannotation_audr ON nex.geninteractionannotation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_geninteractionannotation_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.dbentity1_id != NEW.dbentity1_id) THEN
        PERFORM nex.insertupdatelog('GENINTERACTIONANNOTATION'::text, 'DBENTITY1_ID'::text, OLD.annotation_id, OLD.dbentity1_id::text, NEW.dbentity1_id::text, USER);
    END IF;

    IF (OLD.dbentity2_id != NEW.dbentity2_id) THEN
        PERFORM nex.insertupdatelog('GENINTERACTIONANNOTATION'::text, 'DBENTITY2_ID'::text, OLD.annotation_id, OLD.dbentity2_id::text, NEW.dbentity2_id::text, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('GENINTERACTIONANNOTATION'::text, 'SOURCE_ID'::text, OLD.annotation_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (OLD.reference_id != NEW.reference_id) THEN
        PERFORM nex.insertupdatelog('GENINTERACTIONANNOTATION'::text, 'REFERENCE_ID'::text, OLD.annotation_id, OLD.reference_id::text, NEW.reference_id::text, USER);
    END IF;

     IF (OLD.taxonomy_id != NEW.taxonomy_id) THEN
        PERFORM nex.insertupdatelog('GENINTERACTIONANNOTATION'::text, 'TAXONOMY_ID'::text, OLD.annotation_id, OLD.taxonomy_id::text, NEW.taxonomy_id::text, USER);
    END IF;

    IF (((OLD.phenotype_id IS NULL) AND (NEW.phenotype_id IS NOT NULL)) OR ((OLD.phenotype_id IS NOT NULL) AND (NEW.phenotype_id IS NULL)) OR (OLD.phenotype_id != NEW.phenotype_id)) THEN
        PERFORM nex.insertupdatelog('GENINTERACTIONANNOTATION'::text, 'PHENOTYPE_ID'::text, OLD.annotation_id, OLD.phenotype_id::text, NEW.phenotype_id::text, USER);
    END IF;

    IF (OLD.biogrid_experimental_system != NEW.biogrid_experimental_system) THEN
        PERFORM nex.insertupdatelog('GENINTERACTIONANNOTATION'::text, 'BIOGRID_EXPERIMENTAL_SYSTEM'::text, OLD.annotation_id, OLD.biogrid_experimental_system, NEW.biogrid_experimental_system, USER);
    END IF;

    IF (OLD.annotation_type != NEW.annotation_type) THEN
        PERFORM nex.insertupdatelog('GENINTERACTIONANNOTATION'::text, 'ANNOTATION_TYPE'::text, OLD.annotation_id, OLD.annotation_type, NEW.annotation_type, USER);
    END IF;

    IF (OLD.bait_hit != NEW.bait_hit) THEN
        PERFORM nex.insertupdatelog('GENINTERACTIONANNOTATION'::text, 'BAIT_HIT'::text, OLD.annotation_id, OLD.bait_hit, NEW.bait_hit, USER);
    END IF;

    IF (((OLD.mutant_id IS NULL) AND (NEW.mutant_id IS NOT NULL)) OR ((OLD.mutant_id IS NOT NULL) AND (NEW.mutant_id  IS NULL)) OR (OLD.mutant_id != NEW.mutant_id)) THEN
        PERFORM nex.insertupdatelog('GENINTERACTIONANNOTATION'::text, 'MUTANT_ID'::text, OLD.annotation_id, OLD.mutant_id::text, NEW.mutant_id::text, USER);
    END IF;

    IF (((OLD.description IS NULL) AND (NEW.description IS NOT NULL)) OR ((OLD.description IS NOT NULL) AND (NEW.description IS NULL)) OR (OLD.description != NEW.description)) THEN
        PERFORM nex.insertupdatelog('GENINTERACTIONANNOTATION'::text, 'DESCRIPTION'::text, OLD.annotation_id, OLD.description, NEW.description, USER);
    END IF;

    RETURN NEW;
    
  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.annotation_id || '[:]' || OLD.dbentity1_id || '[:]' ||
             OLD.dbentity2_id || '[:]' || OLD.source_id || '[:]' ||
             OLD.reference_id || '[:]' || OLD.taxonomy_id || '[:]' ||
             coalesce(OLD.phenotype_id,0) || '[:]' || OLD.biogrid_experimental_system || '[:]' ||
	     OLD.annotation_type || '[:]' || OLD.bait_hit || '[:]' ||
	     coalesce(OLD.mutant_id,0) || '[:]' || coalesce(OLD.description,'') || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

          PERFORM nex.insertdeletelog('GENINTERACTIONANNOTATION'::text, OLD.annotation_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER geninteractionannotation_audr
AFTER UPDATE OR DELETE ON nex.geninteractionannotation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_geninteractionannotation_audr();

DROP TRIGGER IF EXISTS geninteractionannotation_biur ON nex.geninteractionannotation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_geninteractionannotation_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.annotation_id != OLD.annotation_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER geninteractionannotation_biur
BEFORE INSERT OR UPDATE ON nex.geninteractionannotation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_geninteractionannotation_biur();


DROP TRIGGER IF EXISTS goannotation_audr ON nex.goannotation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_goannotation_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.dbentity_id != NEW.dbentity_id) THEN
        PERFORM nex.insertupdatelog('GOANNOTATION'::text, 'DBENTITY_ID'::text, OLD.annotation_id, OLD.dbentity_id::text, NEW.dbentity_id::text, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('GOANNOTATION'::text, 'SOURCE_ID'::text, OLD.annotation_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

     IF (OLD.taxonomy_id != NEW.taxonomy_id) THEN
        PERFORM nex.insertupdatelog('GOANNOTATION'::text, 'TAXONOMY_ID'::text, OLD.annotation_id, OLD.taxonomy_id::text, NEW.taxonomy_id::text, USER);
    END IF;

    IF (OLD.reference_id != NEW.reference_id) THEN
        PERFORM nex.insertupdatelog('GOANNOTATION'::text, 'REFERENCE_ID'::text, OLD.annotation_id, OLD.reference_id::text, NEW.reference_id::text, USER);
    END IF;

    IF (OLD.go_id != NEW.go_id) THEN
        PERFORM nex.insertupdatelog('GOANNOTATION'::text, 'GO_ID'::text, OLD.annotation_id, OLD.go_id::text, NEW.go_id::text, USER);
    END IF;

    IF (OLD.eco_id != NEW.eco_id) THEN
        PERFORM nex.insertupdatelog('GOANNOTATION'::text, 'ECO_ID'::text, OLD.annotation_id, OLD.eco_id::text, NEW.eco_id::text, USER);
    END IF;

    IF (OLD.annotation_type != NEW.annotation_type) THEN
        PERFORM nex.insertupdatelog('GOANNOTATION'::text, 'ANNOTATION_TYPE'::text, OLD.annotation_id, OLD.annotation_type, NEW.annotation_type, USER);
    END IF;

    IF (OLD.go_qualifier != NEW.go_qualifier) THEN
        PERFORM nex.insertupdatelog('GOANNOTATION'::text, 'GO_QUALIFIER'::text, OLD.annotation_id, OLD.go_qualifier, NEW.go_qualifier, USER);
    END IF;

    IF (OLD.date_assigned != NEW.date_assigned) THEN
        PERFORM nex.insertupdatelog('GOANNOTATION'::text, 'DATE_ASSIGNED'::text, OLD.annotation_id, OLD.date_assigned::text, NEW.date_assigned::text, USER);
    END IF;

    RETURN NEW;

    ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.annotation_id || '[:]' || OLD.dbentity_id || '[:]' ||
             OLD.source_id || '[:]' || OLD.taxonomy_id || '[:]' ||
             OLD.reference_id || '[:]' || OLD.go_id || '[:]' ||
             OLD.eco_id || '[:]' || OLD.annotation_type || '[:]' ||
             OLD.go_qualifier || '[:]' || OLD.date_assigned || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

          PERFORM nex.insertdeletelog('GOANNOTATION'::text, OLD.annotation_id, v_row, USER);

    RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER goannotation_audr
AFTER UPDATE OR DELETE ON nex.goannotation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_goannotation_audr();

DROP TRIGGER IF EXISTS goannotation_biur ON nex.goannotation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_goannotation_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.annotation_id != OLD.annotation_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER goannotation_biur
BEFORE INSERT OR UPDATE ON nex.goannotation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_goannotation_biur();

DROP TRIGGER IF EXISTS goextension_audr ON nex.goextension CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_goextension_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.annotation_id != NEW.annotation_id) THEN
        PERFORM nex.insertupdatelog('GOEXTENSION'::text, 'ANNOTATION_ID'::text, OLD.goextension_id, OLD.annotation_id::text, NEW.annotation_id::text, USER);
    END IF;

     IF (OLD.group_id != NEW.group_id) THEN
        PERFORM nex.insertupdatelog('GOEXTENSION'::text, 'GROUP_ID'::text, OLD.goextension_id, OLD.group_id::text, NEW.group_id::text, USER);
    END IF;

     IF (OLD.dbxref_id != NEW.dbxref_id) THEN
        PERFORM nex.insertupdatelog('GOEXTENSION'::text, 'DBXREF_ID'::text, OLD.goextension_id, OLD.dbxref_id, NEW.dbxref_id, USER);
    END IF;

     IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('GOEXTENSION'::text, 'OBJ_URL'::text, OLD.goextension_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.ro_id != NEW.ro_id) THEN
        PERFORM nex.insertupdatelog('GOEXTENSION'::text, 'RO_ID'::text, OLD.goextension_id, OLD.ro_id::text, NEW.ro_id::text, USER);
    END IF;

   RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.goextension_id || '[:]' || OLD.annotation_id || '[:]' ||
             OLD.group_id || '[:]' || OLD.dbxref_id || '[:]' ||
             OLD.obj_url || '[:]' || OLD.ro_id || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

         PERFORM nex.insertdeletelog('GOEXTENSION'::text, OLD.goextension_id, v_row, USER);

    RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER goextension_audr
AFTER UPDATE OR DELETE ON nex.goextension FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_goextension_audr();

DROP TRIGGER IF EXISTS goextension_biur ON nex.goextension CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_goextension_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.goextension_id != OLD.goextension_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER goextension_biur
BEFORE INSERT OR UPDATE ON nex.goextension FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_goextension_biur();

DROP TRIGGER IF EXISTS gosupportingevidence_audr ON nex.gosupportingevidence CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_gosupportingevidence_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.annotation_id != NEW.annotation_id) THEN
        PERFORM nex.insertupdatelog('GOSUPPORTINGEVIDENCE'::text, 'ANNOTATION_ID'::text, OLD.gosupportingevidence_id, OLD.annotation_id::text, NEW.annotation_id::text, USER);
    END IF;

     IF (OLD.group_id != NEW.group_id) THEN
        PERFORM nex.insertupdatelog('GOSUPPORTINGEVIDENCE'::text, 'GROUP_ID'::text, OLD.gosupportingevidence_id, OLD.group_id::text, NEW.group_id::text, USER);
    END IF;

     IF (OLD.dbxref_id != NEW.dbxref_id) THEN
        PERFORM nex.insertupdatelog('GOSUPPORTINGEVIDENCE'::text, 'DBXREF_ID'::text, OLD.gosupportingevidence_id, OLD.dbxref_id, NEW.dbxref_id, USER);
    END IF;

     IF (OLD.obj_url != NEW.obj_url) THEN
        PERFORM nex.insertupdatelog('GOSUPPORTINGEVIDENCE'::text, 'OBJ_URL'::text, OLD.gosupportingevidence_id, OLD.obj_url, NEW.obj_url, USER);
    END IF;

     IF (OLD.evidence_type != NEW.evidence_type) THEN
        PERFORM nex.insertupdatelog('GOSUPPORTINGEVIDENCE'::text, 'EVIDENCE_TYPE'::text, OLD.gosupportingevidence_id, OLD.evidence_type, NEW.evidence_type, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.gosupportingevidence_id || '[:]' || OLD.annotation_id || '[:]' ||
             OLD.group_id || '[:]' || OLD.dbxref_id || '[:]' ||
             OLD.obj_url || '[:]' || OLD.evidence_type || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

         PERFORM nex.insertdeletelog('GOSUPPORTINGEVIDENCE'::text, OLD.gosupportingevidence_id, v_row, USER);

    RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER gosupportingevidence_audr
AFTER UPDATE OR DELETE ON nex.gosupportingevidence FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_gosupportingevidence_audr();

DROP TRIGGER IF EXISTS gosupportingevidence_biur ON nex.gosupportingevidence CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_gosupportingevidence_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.gosupportingevidence_id != OLD.gosupportingevidence_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER gosupportingevidence_biur
BEFORE INSERT OR UPDATE ON nex.gosupportingevidence FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_gosupportingevidence_biur();

DROP TRIGGER IF EXISTS goslimannotation_audr ON nex.goslimannotation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_goslimannotation_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.dbentity_id != NEW.dbentity_id) THEN
        PERFORM nex.insertupdatelog('GOSLIMANNOTATION'::text, 'DBENTITY_ID'::text, OLD.annotation_id, OLD.dbentity_id::text, NEW.dbentity_id::text, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('GOSLIMANNOTATION'::text, 'SOURCE_ID'::text, OLD.annotation_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (OLD.taxonomy_id != NEW.taxonomy_id) THEN
        PERFORM nex.insertupdatelog('GOSLIMANNOTATION'::text, 'TAXONOMY_ID'::text, OLD.annotation_id, OLD.taxonomy_id::text, NEW.taxonomy_id::text, USER);
    END IF;

    IF (((OLD.reference_id IS NULL) AND (NEW.reference_id IS NOT NULL)) OR ((OLD.reference_id IS NOT NULL) AND (NEW.reference_id IS NULL)) OR (OLD.reference_id != NEW.reference_id)) THEN
        PERFORM nex.insertupdatelog('GOSLIMANNOTATION'::text, 'REFERENCE_ID'::text, OLD.annotation_id, OLD.reference_id::text, NEW.reference_id::text, USER);
    END IF;

    IF (OLD.goslim_id != NEW.goslim_id) THEN
        PERFORM nex.insertupdatelog('GOSLIMANNOTATION'::text, 'GOSLIM_ID'::text, OLD.annotation_id, OLD.goslim_id::text, NEW.goslim_id::text, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.annotation_id || '[:]' || OLD.dbentity_id || '[:]' ||
             OLD.source_id || '[:]' || OLD.taxonomy_id || '[:]' ||
             coalesce(OLD.reference_id,0) || '[:]' || OLD.goslim_id || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

          PERFORM nex.insertdeletelog('GOSLIMANNOTATION'::text, OLD.annotation_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER goslimannotation_audr
AFTER UPDATE OR DELETE ON nex.goslimannotation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_goslimannotation_audr();

DROP TRIGGER IF EXISTS goslimannotation_biur ON nex.goslimannotation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_goslimannotation_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.annotation_id != OLD.annotation_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

     RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER goslimannotation_biur
BEFORE INSERT OR UPDATE ON nex.goslimannotation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_goslimannotation_biur();


DROP TRIGGER IF EXISTS literatureannotation_audr ON nex.literatureannotation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_literatureannotation_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (((OLD.dbentity_id IS NULL) AND (NEW.dbentity_id IS NOT NULL)) OR ((OLD.dbentity_id IS NOT NULL) AND (NEW.dbentity_id IS NULL)) OR (OLD.dbentity_id != NEW.dbentity_id)) 
    THEN
        PERFORM nex.insertupdatelog('LITERATUREANNOTATION'::text, 'DBENTITY_ID'::text, OLD.annotation_id, OLD.dbentity_id::text, NEW.dbentity_id::text, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('LITERATUREANNOTATION'::text, 'SOURCE_ID'::text, OLD.annotation_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (((OLD.bud_id IS NULL) AND (NEW.bud_id IS NOT NULL)) OR ((OLD.bud_id IS NOT NULL) AND (NEW.bud_id IS NULL)) OR (OLD.bud_id != NEW.bud_id))
    THEN
        PERFORM nex.insertupdatelog('LITERATUREANNOTATION'::text, 'BUD_ID'::text, OLD.annotation_id, OLD.bud_id::text, NEW.bud_id::text, USER);
    END IF;

    IF  (OLD.taxonomy_id != NEW.taxonomy_id) THEN
        PERFORM nex.insertupdatelog('LITERATUREANNOTATION'::text, 'TAXONOMY_ID'::text, OLD.annotation_id, OLD.taxonomy_id::text, NEW.taxonomy_id::text, USER);
    END IF;

    IF (OLD.reference_id != NEW.reference_id) THEN
        PERFORM nex.insertupdatelog('LITERATUREANNOTATION'::text, 'REFERENCE_ID'::text, OLD.annotation_id, OLD.reference_id::text, NEW.reference_id::text, USER);
    END IF;

    IF (OLD.topic != NEW.topic) THEN
        PERFORM nex.insertupdatelog('LITERATUREANNOTATION'::text, 'TOPIC'::text, OLD.annotation_id, OLD.topic, NEW.topic, USER);
    END IF;

    RETURN NEW;
 
  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.annotation_id || '[:]' || coalesce(OLD.dbentity_id,0) || '[:]' ||
             OLD.source_id || '[:]' || coalesce(OLD.bud_id,0) || '[:]' ||
             OLD.taxonomy_id || '[:]' || OLD.reference_id || '[:]' || 
             OLD.topic || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

       PERFORM nex.insertdeletelog('LITERATUREANNOTATION'::text, OLD.annotation_id, v_row, USER);

    RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER literatureannotation_audr
AFTER UPDATE OR DELETE ON nex.literatureannotation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_literatureannotation_audr();

DROP TRIGGER IF EXISTS literatureannotation_biur ON nex.literatureannotation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_literatureannotation_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.annotation_id != OLD.annotation_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER literatureannotation_biur
BEFORE INSERT OR UPDATE ON nex.literatureannotation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_literatureannotation_biur();


DROP TRIGGER IF EXISTS pathwayannotation_audr ON nex.pathwayannotation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_pathwayannotation_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.dbentity_id != NEW.dbentity_id) THEN
        PERFORM nex.insertupdatelog('PATHWAYANNOTATION'::text, 'DBENTITY_ID'::text, OLD.annotation_id, OLD.dbentity_id::text, NEW.dbentity_id::text, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('PATHWAYANNOTATION'::text, 'SOURCE_ID'::text, OLD.annotation_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF  (OLD.taxonomy_id != NEW.taxonomy_id) THEN
        PERFORM nex.insertupdatelog('PATHWAYANNOTATION'::text, 'TAXONOMY_ID'::text, OLD.annotation_id, OLD.taxonomy_id::text, NEW.taxonomy_id::text, USER);
    END IF;

    IF (((OLD.reference_id IS NULL) AND (NEW.reference_id IS NOT NULL)) OR ((OLD.reference_id IS NOT NULL) AND (NEW.reference_id IS NULL)) OR (OLD.reference_id != NEW.reference_id)) THEN
        PERFORM nex.insertupdatelog('PATHWAYANNOTATION'::text, 'REFERENCE_ID'::text, OLD.annotation_id, OLD.reference_id::text, NEW.reference_id::text, USER);
    END IF;

    IF (OLD.pathway_id != NEW.pathway_id) THEN
        PERFORM nex.insertupdatelog('PATHWAYANNOTATION'::text, 'PATHWAY_ID'::text, OLD.annotation_id, OLD.pathway_id::text, NEW.pathway_id::text, USER);
    END IF;

    IF (((OLD.ec_id IS NULL) AND (NEW.ec_id IS NOT NULL)) OR ((OLD.ec_id IS NOT NULL) AND (NEW.ec_id IS NULL)) OR (OLD.ec_id != NEW.ec_id)) THEN
        PERFORM nex.insertupdatelog('PATHWAYANNOTATION'::text, 'EC_ID'::text, OLD.annotation_id, OLD.ec_id::text, NEW.ec_id::text, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.annotation_id || '[:]' || OLD.dbentity_id || '[:]' ||
             OLD.source_id || '[:]' || 
             OLD.taxonomy_id || '[:]' || coalesce(OLD.reference_id,0) || '[:]' ||
             OLD.pathway_id || '[:]' || coalesce(OLD.ec_id,0) || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

         PERFORM nex.insertdeletelog('PATHWAYANNOTATION'::text, OLD.annotation_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER pathwayannotation_audr
AFTER UPDATE OR DELETE ON nex.pathwayannotation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_pathwayannotation_audr();

DROP TRIGGER IF EXISTS pathwayannotation_biur ON nex.pathwayannotation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_pathwayannotation_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.annotation_id != OLD.annotation_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER pathwayannotation_biur
BEFORE INSERT OR UPDATE ON nex.pathwayannotation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_pathwayannotation_biur();


DROP TRIGGER IF EXISTS phenotypeannotation_audr ON nex.phenotypeannotation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_phenotypeannotation_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.dbentity_id != NEW.dbentity_id) THEN
        PERFORM nex.insertupdatelog('PHENOTYPEANNOTATION'::text, 'DBENTITY_ID'::text, OLD.annotation_id, OLD.dbentity_id::text, NEW.dbentity_id::text, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('PHENOTYPEANNOTATION'::text, 'SOURCE_ID'::text, OLD.annotation_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (((OLD.bud_id IS NULL) AND (NEW.bud_id IS NOT NULL)) OR ((OLD.bud_id IS NOT NULL) AND (NEW.bud_id IS NULL)) OR (OLD.bud_id != NEW.bud_id)) THEN
        PERFORM nex.insertupdatelog('PHENOTYPEANNOTATION'::text, 'BUD_ID'::text, OLD.annotation_id, OLD.bud_id::text, NEW.bud_id::text, USER);
    END IF;

    IF  (OLD.taxonomy_id != NEW.taxonomy_id) THEN
        PERFORM nex.insertupdatelog('PHENOTYPEANNOTATION'::text, 'TAXONOMY_ID'::text, OLD.annotation_id, OLD.taxonomy_id::text, NEW.taxonomy_id::text, USER);
    END IF;

    IF (OLD.reference_id != NEW.reference_id) THEN
        PERFORM nex.insertupdatelog('PHENOTYPEANNOTATION'::text, 'REFERENCE_ID'::text, OLD.annotation_id, OLD.reference_id::text, NEW.reference_id::text, USER);
    END IF;

    IF (OLD.phenotype_id != NEW.phenotype_id) THEN
        PERFORM nex.insertupdatelog('PHENOTYPEANNOTATION'::text, 'PHENOTYPE_ID'::text, OLD.annotation_id, OLD.phenotype_id::text, NEW.phenotype_id::text, USER);
    END IF;

    IF (OLD.experiment_id != NEW.experiment_id) THEN
        PERFORM nex.insertupdatelog('PHENOTYPEANNOTATION'::text, 'EXPERIMENT_ID'::text, OLD.annotation_id, OLD.experiment_id::text, NEW.experiment_id::text, USER);
    END IF;

    IF (OLD.mutant_id != NEW.mutant_id) THEN
        PERFORM nex.insertupdatelog('PHENOTYPEANNOTATION'::text, 'MUTANT_ID'::text, OLD.annotation_id, OLD.mutant_id::text, NEW.mutant_id::text, USER);
    END IF;

    IF  (((OLD.allele_id IS NULL) AND (NEW.allele_id IS NOT NULL)) OR ((OLD.allele_id IS NOT NULL) AND (NEW.allele_id IS NULL)) OR (OLD.allele_id != NEW.allele_id)) THEN
        PERFORM nex.insertupdatelog('PHENOTYPEANNOTATION'::text, 'ALLELE_ID'::text, OLD.annotation_id, OLD.allele_id::text, NEW.allele_id::text, USER);
    END IF;

    IF  (((OLD.reporter_id IS NULL) AND (NEW.reporter_id IS NOT NULL)) OR ((OLD.reporter_id IS NOT NULL) AND (NEW.reporter_id IS NULL)) OR (OLD.reporter_id != NEW.reporter_id)) THEN
        PERFORM nex.insertupdatelog('PHENOTYPEANNOTATION'::text, 'REPORTER_ID'::text, OLD.annotation_id, OLD.reporter_id::text, NEW.reporter_id::text, USER);
    END IF;

    IF  (((OLD.assay_id IS NULL) AND (NEW.assay_id IS NOT NULL)) OR ((OLD.assay_id IS NOT NULL) AND (NEW.assay_id IS NULL)) OR (OLD.assay_id != NEW.assay_id)) THEN
        PERFORM nex.insertupdatelog('PHENOTYPEANNOTATION'::text, 'ASSAY_ID'::text, OLD.annotation_id, OLD.assay_id::text, NEW.assay_id::text, USER);
    END IF;

    IF  (((OLD.strain_name IS NULL) AND (NEW.strain_name IS NOT NULL)) OR ((OLD.strain_name IS NOT NULL) AND (NEW.strain_name IS NULL)) OR (OLD.strain_name != NEW.strain_name)) THEN
        PERFORM nex.insertupdatelog('PHENOTYPEANNOTATION'::text, 'STRAIN_NAME'::text, OLD.annotation_id, OLD.strain_name, NEW.strain_name, USER);
    END IF;

    IF  (((OLD.experiment_comment IS NULL) AND (NEW.experiment_comment IS NOT NULL)) OR ((OLD.experiment_comment IS NOT NULL) AND (NEW.experiment_comment IS NULL)) OR (OLD.experiment_comment != NEW.experiment_comment)) THEN
        PERFORM nex.insertupdatelog('PHENOTYPEANNOTATION'::text, 'EXPERIMENT_COMMENT'::text, OLD.annotation_id, OLD.experiment_comment, NEW.experiment_comment, USER);
    END IF;

    IF  (((OLD.allele_comment IS NULL) AND (NEW.allele_comment IS NOT NULL)) OR ((OLD.allele_comment IS NOT NULL) AND (NEW.allele_comment IS NULL)) OR (OLD.allele_comment != NEW.allele_comment)) THEN
        PERFORM nex.insertupdatelog('PHENOTYPEANNOTATION'::text, 'ALLELE_COMMENT'::text, OLD.annotation_id, OLD.allele_comment, NEW.allele_comment, USER);
    END IF;

    IF  (((OLD.reporter_comment IS NULL) AND (NEW.reporter_comment IS NOT NULL)) OR ((OLD.reporter_comment IS NOT NULL) AND (NEW.reporter_comment IS NULL)) OR (OLD.reporter_comment != NEW.reporter_comment)) THEN
        PERFORM nex.insertupdatelog('PHENOTYPEANNOTATION'::text, 'REPORTER_COMMENT'::text, OLD.annotation_id, OLD.reporter_comment, NEW.reporter_comment, USER);
    END IF;

    IF  (((OLD.details IS NULL) AND (NEW.details IS NOT NULL)) OR ((OLD.details IS NOT NULL) AND (NEW.details IS NULL)) OR (OLD.details != NEW.details)) THEN
        PERFORM nex.insertupdatelog('PHENOTYPEANNOTATION'::text, 'DETAILS'::text, OLD.annotation_id, OLD.details, NEW.details, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.annotation_id || '[:]' || OLD.dbentity_id || '[:]' ||
             OLD.source_id || '[:]' || coalesce(OLD.bud_id,0) || '[:]' ||
             OLD.taxonomy_id || '[:]' || OLD.reference_id || '[:]' ||
             OLD.phenotype_id || '[:]' || OLD.experiment_id || '[:]' ||
             OLD.mutant_id || '[:]' || coalesce(OLD.allele_id,0) || '[:]' ||
             coalesce(OLD.reporter_id,0) || '[:]' || coalesce(OLD.assay_id,0) || '[:]' ||
             coalesce(OLD.strain_name,'') || '[:]' || coalesce(OLD.experiment_comment,'') || '[:]' ||
             coalesce(OLD.allele_comment,'') || '[:]' || coalesce(OLD.reporter_comment,'') || '[:]' ||
             coalesce(OLD.details,'') || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

           PERFORM nex.insertdeletelog('PHENOTYPEANNOTATION'::text, OLD.annotation_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER phenotypeannotation_audr
AFTER UPDATE OR DELETE ON nex.phenotypeannotation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_phenotypeannotation_audr();

DROP TRIGGER IF EXISTS phenotypeannotation_biur ON nex.phenotypeannotation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_phenotypeannotation_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       PERFORM nex.checkphenotype(NEW.experiment_id, 'experiment_type');
       PERFORM nex.checkphenotype(NEW.mutant_id, 'mutant_type');

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.annotation_id != OLD.annotation_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    PERFORM nex.checkphenotype(NEW.experiment_id, 'experiment_type');
    PERFORM nex.checkphenotype(NEW.mutant_id, 'mutant_type');

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER phenotypeannotation_biur
BEFORE INSERT OR UPDATE ON nex.phenotypeannotation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_phenotypeannotation_biur();

DROP TRIGGER IF EXISTS phenotypeannotationcond_audr ON nex.phenotypeannotation_cond CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_phenotypeannotationcond_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.annotation_id != NEW.annotation_id) THEN
        PERFORM nex.insertupdatelog('PHENOTYPEANNOTATION_COND'::text, 'ANNOTATION_ID'::text, OLD.condition_id, OLD.annotation_id::text, NEW.annotation_id::text, USER);
    END IF;

    IF (OLD.group_id != NEW.group_id) THEN
        PERFORM nex.insertupdatelog('PHENOTYPEANNOTATION_COND'::text, 'GROUP_ID'::text, OLD.condition_id, OLD.group_id::text, NEW.group_id::text, USER);
    END IF;

     IF (OLD.condition_class != NEW.condition_class) THEN
        PERFORM nex.insertupdatelog('PHENOTYPEANNOTATION_COND'::text, 'CONDITION_CLASS'::text, OLD.condition_id, OLD.condition_class, NEW.condition_class, USER);
    END IF;

     IF (OLD.condition_name != NEW.condition_name) THEN
        PERFORM nex.insertupdatelog('PHENOTYPEANNOTATION_COND'::text, 'CONDITION_NAME'::text, OLD.condition_id, OLD.condition_name, NEW.condition_name, USER);
    END IF;

     IF (((OLD.condition_value IS NULL) AND (NEW.condition_value IS NOT NULL)) OR ((OLD.condition_value IS NOT NULL) AND (NEW.condition_value IS NULL)) OR (OLD.condition_value != NEW.condition_value)) THEN
        PERFORM nex.insertupdatelog('PHENOTYPEANNOTATION_COND'::text, 'CONDITION_VALUE'::text, OLD.condition_id, OLD.condition_value, NEW.condition_value, USER);
    END IF;

     IF (((OLD.condition_unit IS NULL) AND (NEW.condition_unit IS NOT NULL)) OR ((OLD.condition_unit IS NOT NULL) AND (NEW.condition_unit IS NULL)) OR (OLD.condition_unit != NEW.condition_unit)) THEN
        PERFORM nex.insertupdatelog('PHENOTYPEANNOTATION_COND'::text, 'CONDITION_UNIT'::text, OLD.condition_id, OLD.condition_unit, NEW.condition_unit, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.condition_id || '[:]' || OLD.annotation_id || '[:]' ||
             OLD.group_id || '[:]' ||
             OLD.condition_class || '[:]' || OLD.condition_name || '[:]' ||
             coalesce(OLD.condition_value,'') || '[:]' || coalesce(OLD.condition_unit,'') || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

          PERFORM nex.insertdeletelog('PHENOTYPEANNOTATION_COND'::text, OLD.condition_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER phenotypeannotationcond_audr
AFTER UPDATE OR DELETE ON nex.phenotypeannotation_cond FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_phenotypeannotationcond_audr();

DROP TRIGGER IF EXISTS phenotypeannotationcond_biur ON nex.phenotypeannotation_cond CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_phenotypeannotationcond_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

    IF (NEW.condition_class = 'chemical') THEN
        PERFORM nex.checkchemical(NEW.condition_name);
    END IF;

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.condition_id != OLD.condition_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.condition_class = 'chemical') THEN
        PERFORM nex.checkchemical(NEW.condition_name);
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER phenotypeannotationcond_biur
BEFORE INSERT OR UPDATE ON nex.phenotypeannotation_cond FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_phenotypeannotationcond_biur();


DROP TRIGGER IF EXISTS physinteractionannotation_audr ON nex.physinteractionannotation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_physinteractionannotation_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.dbentity1_id != NEW.dbentity1_id) THEN
        PERFORM nex.insertupdatelog('PHYSINTERACTIONANNOTATION'::text, 'DBENTITY1_ID'::text, OLD.annotation_id, OLD.dbentity1_id::text, NEW.dbentity1_id::text, USER);
    END IF;

    IF (OLD.dbentity2_id != NEW.dbentity2_id) THEN
        PERFORM nex.insertupdatelog('PHYSINTERACTIONANNOTATION'::text, 'DBENTITY2_ID'::text, OLD.annotation_id, OLD.dbentity2_id::text, NEW.dbentity2_id::text, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('PHYSINTERACTIONANNOTATION'::text, 'SOURCE_ID'::text, OLD.annotation_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (OLD.reference_id != NEW.reference_id) THEN
        PERFORM nex.insertupdatelog('PHYSINTERACTIONANNOTATION'::text, 'REFERENCE_ID'::text, OLD.annotation_id, OLD.reference_id::text, NEW.reference_id::text, USER);
    END IF;

     IF (OLD.taxonomy_id != NEW.taxonomy_id) THEN
        PERFORM nex.insertupdatelog('PHYSINTERACTIONANNOTATION'::text, 'TAXONOMY_ID'::text, OLD.annotation_id, OLD.taxonomy_id::text, NEW.taxonomy_id::text, USER);
    END IF;

    IF  (((OLD.psimod_id IS NULL) AND (NEW.psimod_id IS NOT NULL)) OR ((OLD.psimod_id IS NOT NULL) AND (NEW.psimod_id IS NULL)) OR (OLD.psimod_id != NEW.psimod_id)) THEN
        PERFORM nex.insertupdatelog('PHYSINTERACTIONANNOTATION'::text, 'PSIMOD_ID'::text, OLD.annotation_id, OLD.psimod_id::text, NEW.psimod_id::text, USER);
    END IF;

    IF (OLD.biogrid_experimental_system != NEW.biogrid_experimental_system) THEN
        PERFORM nex.insertupdatelog('PHYSINTERACTIONANNOTATION'::text, 'BIOGRID_EXPERIMENTAL_SYSTEM'::text, OLD.annotation_id, OLD.biogrid_experimental_system, NEW.biogrid_experimental_system, USER);
    END IF;

    IF (OLD.annotation_type != NEW.annotation_type) THEN
        PERFORM nex.insertupdatelog('PHYSINTERACTIONANNOTATION'::text, 'ANNOTATION_TYPE'::text, OLD.annotation_id, OLD.annotation_type, NEW.annotation_type, USER);
    END IF;

    IF (OLD.bait_hit != NEW.bait_hit) THEN
        PERFORM nex.insertupdatelog('PHYSINTERACTIONANNOTATION'::text, 'BAIT_HIT'::text, OLD.annotation_id, OLD.bait_hit, NEW.bait_hit, USER);
    END IF;

    IF (((OLD.description IS NULL) AND (NEW.description IS NOT NULL)) OR ((OLD.description IS NOT NULL) AND (NEW.description IS NULL)) OR (OLD.description != NEW.description)) THEN
        PERFORM nex.insertupdatelog('PHYSINTERACTIONANNOTATION'::text, 'DESCRIPTION'::text, OLD.annotation_id, OLD.description, NEW.description, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.annotation_id || '[:]' || OLD.dbentity1_id || '[:]' ||
             OLD.dbentity2_id || '[:]' || OLD.source_id || '[:]' ||
             OLD.reference_id || '[:]' || OLD.taxonomy_id || '[:]' ||
             coalesce(OLD.psimod_id,0) || '[:]' ||
             OLD.biogrid_experimental_system || '[:]' || OLD.annotation_type || '[:]' ||
             OLD.bait_hit || '[:]' || coalesce(OLD.description,'') || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

        PERFORM nex.insertdeletelog('PHYSINTERACTIONANNOTATION'::text, OLD.annotation_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER physinteractionannotation_audr
AFTER UPDATE OR DELETE ON nex.physinteractionannotation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_physinteractionannotation_audr();

DROP TRIGGER IF EXISTS physinteractionannotation_biur ON nex.physinteractionannotation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_physinteractionannotation_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.annotation_id != OLD.annotation_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER physinteractionannotation_biur
BEFORE INSERT OR UPDATE ON nex.physinteractionannotation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_physinteractionannotation_biur();


DROP TRIGGER IF EXISTS posttranslationannotation_audr ON nex.posttranslationannotation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_posttranslationannotation_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.dbentity_id != NEW.dbentity_id) THEN
        PERFORM nex.insertupdatelog('POSTTRANSLATIONANNOTATION'::text, 'DBENTITY_ID'::text, OLD.annotation_id, OLD.dbentity_id::text, NEW.dbentity_id::text, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('POSTTRANSLATIONANNOTATION'::text, 'SOURCE_ID'::text, OLD.annotation_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (OLD.taxonomy_id != NEW.taxonomy_id) THEN
        PERFORM nex.insertupdatelog('POSTTRANSLATIONANNOTATION'::text, 'TAXONOMY_ID'::text, OLD.annotation_id, OLD.taxonomy_id::text, NEW.taxonomy_id::text, USER);
    END IF;

    IF (OLD.reference_id != NEW.reference_id) THEN
        PERFORM nex.insertupdatelog('POSTTRANSLATIONANNOTATION'::text, 'REFERENCE_ID'::text, OLD.annotation_id, OLD.reference_id::text, NEW.reference_id::text, USER);
    END IF;

    IF (OLD.site_index != NEW.site_index) THEN
        PERFORM nex.insertupdatelog('POSTTRANSLATIONANNOTATION'::text, 'SITE_INDEX'::text, OLD.annotation_id, OLD.site_index::text, NEW.site_index::text, USER);
    END IF;

    IF (OLD.site_residue != NEW.site_residue) THEN
        PERFORM nex.insertupdatelog('POSTTRANSLATIONANNOTATION'::text, 'SITE_RESIDUE'::text, OLD.annotation_id, OLD.site_residue, NEW.site_residue, USER);
    END IF;

    IF (OLD.psimod_id != NEW.psimod_id) THEN
        PERFORM nex.insertupdatelog('POSTTRANSLATIONANNOTATION'::text, 'PSIMOD_ID'::text, OLD.annotation_id, OLD.psimod_id::text, NEW.psimod_id::text, USER);
    END IF;

    IF (((OLD.modifier_id IS NULL) AND (NEW.modifier_id IS NOT NULL)) OR ((OLD.modifier_id IS NOT NULL) AND (NEW.modifier_id IS NULL)) OR (OLD.modifier_id != NEW.modifier_id)) THEN
        PERFORM nex.insertupdatelog('POSTTRANSLATIONANNOTATION'::text, 'MODIFIER_ID'::text, OLD.annotation_id, OLD.modifier_id::text, NEW.modifier_id::text, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.annotation_id || '[:]' || OLD.dbentity_id || '[:]' ||
             OLD.source_id || '[:]' || OLD.taxonomy_id || '[:]' ||
             OLD.reference_id || '[:]' || 
             OLD.site_index || '[:]' || OLD.site_residue || '[:]' ||
             OLD.psimod_id || '[:]' || coalesce(OLD.modifier_id,0) || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

          PERFORM nex.insertdeletelog('POSTTRANSLATIONANNOTATION'::text, OLD.annotation_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER posttranslationannotation_audr
AFTER UPDATE OR DELETE ON nex.posttranslationannotation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_posttranslationannotation_audr();

DROP TRIGGER IF EXISTS posttranslationannotation_biur ON nex.posttranslationannotation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_posttranslationannotation_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.annotation_id != OLD.annotation_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER posttranslationannotation_biur
BEFORE INSERT OR UPDATE ON nex.posttranslationannotation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_posttranslationannotation_biur();


DROP TRIGGER IF EXISTS proteindomainannotation_audr ON nex.proteindomainannotation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_proteindomainannotation_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.dbentity_id != NEW.dbentity_id) THEN
        PERFORM nex.insertupdatelog('PROTEINDOMAINANNOTATION'::text, 'DBENTITY_ID'::text, OLD.annotation_id, OLD.dbentity_id::text, NEW.dbentity_id::text, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('PROTEINDOMAINANNOTATION'::text, 'SOURCE_ID'::text, OLD.annotation_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (OLD.taxonomy_id != NEW.taxonomy_id) THEN
        PERFORM nex.insertupdatelog('PROTEINDOMAINANNOTATION'::text, 'TAXONOMY_ID'::text, OLD.annotation_id, OLD.taxonomy_id::text, NEW.taxonomy_id::text, USER);
    END IF;

    IF  (((OLD.reference_id IS NULL) AND (NEW.reference_id IS NOT NULL)) OR ((OLD.reference_id IS NOT NULL) AND (NEW.reference_id IS NULL)) OR (OLD.reference_id != NEW.reference_id)) THEN
        PERFORM nex.insertupdatelog('PROTEINDOMAINANNOTATION'::text, 'REFERENCE_ID'::text, OLD.annotation_id, OLD.reference_id::text, NEW.reference_id::text, USER);
    END IF;

    IF (OLD.proteindomain_id != NEW.proteindomain_id) THEN
        PERFORM nex.insertupdatelog('PROTEINDOMAINANNOTATION'::text, 'PROTEINDOMAIN_ID'::text, OLD.annotation_id, OLD.proteindomain_id::text, NEW.proteindomain_id::text, USER);
    END IF;

    IF (OLD.start_index != NEW.start_index) THEN
        PERFORM nex.insertupdatelog('PROTEINDOMAINANNOTATION'::text, 'START_INDEX'::text, OLD.annotation_id, OLD.start_index::text, NEW.start_index::text, USER);
    END IF;

    IF (OLD.end_index != NEW.end_index) THEN
        PERFORM nex.insertupdatelog('PROTEINDOMAINANNOTATION'::text, 'END_INDEX'::text, OLD.annotation_id, OLD.end_index::text, NEW.end_index::text, USER);
    END IF;

    IF (OLD.date_of_run != NEW.date_of_run) THEN
        PERFORM nex.insertupdatelog('PROTEINDOMAINANNOTATION'::text, 'DATE_OF_RUN'::text, OLD.annotation_id, OLD.date_of_run::text, NEW.date_of_run::text, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.annotation_id || '[:]' || OLD.dbentity_id || '[:]' ||
             OLD.source_id || '[:]' || OLD.taxonomy_id || '[:]' ||
             coalesce(OLD.reference_id,0) || '[:]' || 
             OLD.proteindomain_id || '[:]' || OLD.start_index || '[:]' ||
             OLD.end_index || '[:]' || OLD.date_of_run || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

         PERFORM nex.insertdeletelog('PROTEINDOMAINANNOTATION'::text, OLD.annotation_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER proteindomainannotation_audr
AFTER UPDATE OR DELETE ON nex.proteindomainannotation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_proteindomainannotation_audr();

DROP TRIGGER IF EXISTS proteindomainannotation_biur ON nex.proteindomainannotation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_proteindomainannotation_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.annotation_id != OLD.annotation_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER proteindomainannotation_biur
BEFORE INSERT OR UPDATE ON nex.proteindomainannotation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_proteindomainannotation_biur();


DROP TRIGGER IF EXISTS proteinexptannotation_audr ON nex.proteinexptannotation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_proteinexptannotation_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.dbentity_id != NEW.dbentity_id) THEN
        PERFORM nex.insertupdatelog('PROTEINEXPTANNOTATION'::text, 'DBENTITY_ID'::text, OLD.annotation_id, OLD.dbentity_id::text, NEW.dbentity_id::text, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('PROTEINEXPTANNOTATION'::text, 'SOURCE_ID'::text, OLD.annotation_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (OLD.taxonomy_id != NEW.taxonomy_id) THEN
        PERFORM nex.insertupdatelog('PROTEINEXPTANNOTATION'::text, 'TAXONOMY_ID'::text, OLD.annotation_id, OLD.taxonomy_id::text, NEW.taxonomy_id::text, USER);
    END IF;

    IF  (OLD.reference_id != NEW.reference_id) THEN
        PERFORM nex.insertupdatelog('PROTEINEXPTANNOTATION'::text, 'REFERENCE_ID'::text, OLD.annotation_id, OLD.reference_id::text, NEW.reference_id::text, USER);
    END IF;

    IF (OLD.experiment_type != NEW.experiment_type) THEN
        PERFORM nex.insertupdatelog('PROTEINEXPTANNOTATION'::text, 'EXPERIMENT_TYPE'::text, OLD.annotation_id, OLD.experiment_type, NEW.experiment_type, USER);
    END IF;

    IF (OLD.data_value != NEW.data_value) THEN
        PERFORM nex.insertupdatelog('PROTEINEXPTANNOTATION'::text, 'DATA_VALUE'::text, OLD.annotation_id, OLD.data_value, NEW.data_value, USER);
    END IF;

    IF (OLD.data_unit != NEW.data_unit) THEN
        PERFORM nex.insertupdatelog('PROTEINEXPTANNOTATION'::text, 'DATA_UNIT'::text, OLD.annotation_id, OLD.data_unit, NEW.data_unit, USER);
    END IF;

    IF (((OLD.assay_id IS NULL) AND (NEW.assay_id IS NOT NULL)) OR ((OLD.assay_id IS NOT NULL) AND (NEW.assay_id IS NULL)) OR (OLD.assay_id != NEW.assay_id)) THEN
        PERFORM nex.insertupdatelog('PROTEINEXPTANNOTATION'::text, 'ASSAY_ID'::text, OLD.annotation_id, OLD.assay_id::text, NEW.assay_id::text, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.annotation_id || '[:]' || OLD.dbentity_id || '[:]' ||
             OLD.source_id || '[:]' || OLD.taxonomy_id || '[:]' ||
             OLD.reference_id || '[:]' || 
             OLD.experiment_type || '[:]' || OLD.data_value || '[:]' ||
             OLD.data_unit || '[:]' || coalesce(OLD.assay_id,0) || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

         PERFORM nex.insertdeletelog('PROTEINEXPTANNOTATION'::text, OLD.annotation_id, v_row, USER);

    RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER proteinexptannotation_audr
AFTER UPDATE OR DELETE ON nex.proteinexptannotation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_proteinexptannotation_audr();

DROP TRIGGER IF EXISTS proteinexptannotation_biur ON nex.proteinexptannotation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_proteinexptannotation_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.annotation_id != OLD.annotation_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER proteinexptannotation_biur
BEFORE INSERT OR UPDATE ON nex.proteinexptannotation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_proteinexptannotation_biur();

DROP TRIGGER IF EXISTS proteinexptannotationcond_audr ON nex.proteinexptannotation_cond CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_proteinexptannotationcond_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.annotation_id != NEW.annotation_id) THEN
        PERFORM nex.insertupdatelog('PROTEINEXPTANNOTATION_COND'::text, 'ANNOTATION_ID'::text, OLD.condition_id, OLD.annotation_id::text, NEW.annotation_id::text, USER);
    END IF;

     IF (OLD.condition_class != NEW.condition_class) THEN
        PERFORM nex.insertupdatelog('PROTEINEXPTANNOTATION_COND'::text, 'CONDITION_CLASS'::text, OLD.condition_id, OLD.condition_class, NEW.condition_class, USER);
    END IF;

     IF (OLD.condition_name != NEW.condition_name) THEN
        PERFORM nex.insertupdatelog('PROTEINEXPTANNOTATION_COND'::text, 'CONDITION_NAME'::text, OLD.condition_id, OLD.condition_name, NEW.condition_name, USER);
    END IF;

    IF (((OLD.condition_value IS NULL) AND (NEW.condition_value IS NOT NULL)) OR ((OLD.condition_value IS NOT NULL) AND (NEW.condition_value IS NULL)) OR (OLD.condition_value != NEW.condition_value)) THEN
        PERFORM nex.insertupdatelog('PROTEINEXPTANNOTATION_COND'::text, 'CONDITION_VALUE'::text, OLD.condition_id, OLD.condition_value, NEW.condition_value, USER);
    END IF;

    IF (((OLD.condition_unit IS NULL) AND (NEW.condition_unit IS NOT NULL)) OR ((OLD.condition_unit IS NOT NULL) AND (NEW.condition_unit IS NULL)) OR (OLD.condition_unit != NEW.condition_unit)) THEN
        PERFORM nex.insertupdatelog('PROTEINEXPTANNOTATION_COND'::text, 'CONDITION_UNIT'::text, OLD.condition_id, OLD.condition_unit, NEW.condition_unit, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.condition_id || '[:]' || OLD.annotation_id || '[:]' ||
             OLD.condition_class || '[:]' || OLD.condition_name || '[:]' ||
             coalesce(OLD.condition_value,'') || '[:]' || coalesce(OLD.condition_unit,'') || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

         PERFORM nex.insertdeletelog('PROTEINEXPTANNOTATION_COND'::text, OLD.condition_id, v_row, USER);

    RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER proteinexptannotationcond_audr
AFTER UPDATE OR DELETE ON nex.proteinexptannotation_cond FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_proteinexptannotationcond_audr();

DROP TRIGGER IF EXISTS proteinexptannotationcond_biur ON nex.proteinexptannotation_cond CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_proteinexptannotationcond_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

    IF (NEW.condition_class = 'chemical') THEN
        PERFORM nex.checkchemical(NEW.condition_name);
    END IF;

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.condition_id != OLD.condition_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.condition_class = 'chemical') THEN
        PERFORM nex.checkchemical(NEW.condition_name);
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER proteinexptannotationcond_biur
BEFORE INSERT OR UPDATE ON nex.proteinexptannotation_cond FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_proteinexptannotationcond_biur();


DROP TRIGGER IF EXISTS proteinsequenceannotation_audr ON nex.proteinsequenceannotation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_proteinsequenceannotation_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.dbentity_id != NEW.dbentity_id) THEN
        PERFORM nex.insertupdatelog('PROTEINSEQUENCEANNOTATION'::text, 'DBENTITY_ID'::text, OLD.annotation_id, OLD.dbentity_id::text, NEW.dbentity_id::text, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('PROTEINSEQUENCEANNOTATION'::text, 'SOURCE_ID'::text, OLD.annotation_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

     IF (OLD.taxonomy_id != NEW.taxonomy_id) THEN
        PERFORM nex.insertupdatelog('PROTEINSEQUENCEANNOTATION'::text, 'TAXONOMY_ID'::text, OLD.annotation_id, OLD.taxonomy_id::text, NEW.taxonomy_id::text, USER);
    END IF;

    IF (((OLD.reference_id IS NULL) AND (NEW.reference_id IS NOT NULL)) OR ((OLD.reference_id IS NOT NULL) AND (NEW.reference_id IS NULL)) OR (OLD.reference_id != NEW.reference_id)) THEN
        PERFORM nex.insertupdatelog('PROTEINSEQUENCEANNOTATION'::text, 'REFERENCE_ID'::text, OLD.annotation_id, OLD.reference_id::text, NEW.reference_id::text, USER);
    END IF;

    IF (((OLD.bud_id IS NULL) AND (NEW.bud_id IS NOT NULL)) OR ((OLD.bud_id IS NOT NULL) AND (NEW.bud_id IS NULL)) OR (OLD.bud_id != NEW.bud_id)) THEN
        PERFORM nex.insertupdatelog('PROTEINSEQUENCEANNOTATION'::text, 'BUD_ID'::text, OLD.annotation_id, OLD.bud_id::text, NEW.bud_id::text, USER);
    END IF;

    IF (OLD.contig_id != NEW.contig_id) THEN
        PERFORM nex.insertupdatelog('PROTEINSEQUENCEANNOTATION'::text, 'CONTIG_ID'::text, OLD.annotation_id, OLD.contig_id::text, NEW.contig_id::text, USER);
    END IF;

    IF (((OLD.seq_version IS NULL) AND (NEW.seq_version IS NOT NULL)) OR ((OLD.seq_version IS NOT NULL) AND (NEW.seq_version IS NULL)) OR (OLD.seq_version != NEW.seq_version)) THEN
        PERFORM nex.insertupdatelog('PROTEINSEQUENCEANNOTATION'::text, 'SEQ_VERSION'::text, OLD.annotation_id, OLD.seq_version::text, NEW.seq_version::text, USER);
    END IF;

    IF (((OLD.genomerelease_id IS NULL) AND (NEW.genomerelease_id IS NOT NULL)) OR ((OLD.genomerelease_id IS NOT NULL) AND (NEW.genomerelease_id IS NULL)) OR (OLD.genomerelease_id != NEW.genomerelease_id)) THEN
        PERFORM nex.insertupdatelog('PROTEINSEQUENCEANNOTATION'::text, 'GENOMERELEASE_ID'::text, OLD.annotation_id, OLD.genomerelease_id::text, NEW.genomerelease_id::text, USER);
    END IF;

    IF (OLD.file_header != NEW.file_header) THEN
        PERFORM nex.insertupdatelog('PROTEINSEQUENCEANNOTATION'::text, 'FILE_HEADER'::text, OLD.annotation_id, OLD.file_header, NEW.file_header, USER);
    END IF;

    IF (OLD.download_filename != NEW.download_filename) THEN
        PERFORM nex.insertupdatelog('PROTEINSEQUENCEANNOTATION'::text, 'DOWNLOAD_FILENAME'::text, OLD.annotation_id, OLD.download_filename, NEW.download_filename, USER);
    END IF;

    IF (((OLD.file_id IS NULL) AND (NEW.file_id IS NOT NULL)) OR ((OLD.file_id IS NOT NULL) AND (NEW.file_id IS NULL)) OR (OLD.file_id != NEW.file_id)) THEN
        PERFORM nex.insertupdatelog('PROTEINSEQUENCEANNOTATION'::text, 'FILE_ID'::text, OLD.annotation_id, OLD.file_id::text, NEW.file_id::text, USER);
    END IF;

     IF (OLD.residues != NEW.residues) THEN
        PERFORM nex.insertupdatelog('PROTEINSEQUENCEANNOTATION'::text, 'RESIDUES'::text, OLD.annotation_id, OLD.residues, NEW.residues, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.annotation_id || '[:]' || OLD.dbentity_id || '[:]' ||
             OLD.source_id || '[:]' || OLD.taxonomy_id || '[:]' ||
             coalesce(OLD.reference_id,0) || '[:]' || coalesce(OLD.bud_id,0) || '[:]' ||
             OLD.contig_id || '[:]' || coalesce(OLD.seq_version,'') || '[:]' ||
             coalesce(OLD.genomerelease_id,0) || '[:]' || OLD.file_header || '[:]' ||
             OLD.download_filename || '[:]' || coalesce(OLD.file_id,0) || '[:]' ||
             OLD.residues || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

           PERFORM nex.insertdeletelog('PROTEINSEQUENCEANNOTATION'::text, OLD.annotation_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER proteinsequenceannotation_audr
AFTER UPDATE OR DELETE ON nex.proteinsequenceannotation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_proteinsequenceannotation_audr();

DROP TRIGGER IF EXISTS proteinsequenceannotation_biur ON nex.proteinsequenceannotation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_proteinsequenceannotation_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.annotation_id != OLD.annotation_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER proteinsequenceannotation_biur
BEFORE INSERT OR UPDATE ON nex.proteinsequenceannotation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_proteinsequenceannotation_biur();

DROP TRIGGER IF EXISTS proteinsequencedetail_audr ON nex.proteinsequence_detail CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_proteinsequencedetail_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.annotation_id != NEW.annotation_id) THEN
        PERFORM nex.insertupdatelog('PROTEINSEQUENCE_DETAIL'::text, 'ANNOTATION_ID'::text, OLD.detail_id, OLD.ANNOTATION_ID::text, NEW.annotation_id::text, USER);
    END IF;

    IF (OLD.molecular_weight != NEW.molecular_weight) THEN
        PERFORM nex.insertupdatelog('PROTEINSEQUENCE_DETAIL'::text, 'MOLECULAR_WEIGHT'::text, OLD.detail_id, OLD.MOLECULAR_WEIGHT::text, NEW.molecular_weight::text, USER);
    END IF;

    IF (OLD.protein_length != NEW.protein_length) THEN
        PERFORM nex.insertupdatelog('PROTEINSEQUENCE_DETAIL'::text, 'PROTEIN_LENGTH'::text, OLD.detail_id, OLD.PROTEIN_LENGTH::text, NEW.protein_length::text, USER);
    END IF;

    IF (OLD.n_term_seq != NEW.n_term_seq) THEN
        PERFORM nex.insertupdatelog('PROTEINSEQUENCE_DETAIL'::text, 'N_TERM_SEQ'::text, OLD.detail_id, OLD.N_TERM_SEQ, NEW.n_term_seq, USER);
    END IF;

    IF (OLD.c_term_seq != NEW.c_term_seq) THEN
        PERFORM nex.insertupdatelog('PROTEINSEQUENCE_DETAIL'::text, 'C_TERM_SEQ'::text, OLD.detail_id, OLD.C_TERM_SEQ, NEW.c_term_seq, USER);
    END IF;

    IF (((OLD.pi IS NULL) AND (NEW.pi IS NOT NULL)) OR ((OLD.pi IS NOT NULL) AND (NEW.pi IS NULL)) OR (OLD.pi != NEW.pi)) THEN
        PERFORM nex.insertupdatelog('PROTEINSEQUENCE_DETAIL'::text, 'PI'::text, OLD.detail_id, OLD.pi::text, NEW.pi::text, USER);
    END IF;

    IF (((OLD.cai IS NULL) AND (NEW.cai IS NOT NULL)) OR ((OLD.cai IS NOT NULL) AND (NEW.cai IS NULL)) OR (OLD.cai != NEW.cai)) THEN
        PERFORM nex.insertupdatelog('PROTEINSEQUENCE_DETAIL'::text, 'CAI'::text, OLD.detail_id, OLD.CAI::text, NEW.cai::text, USER);
    END IF;

    IF (((OLD.codon_bias IS NULL) AND (NEW.codon_bias IS NOT NULL)) OR ((OLD.codon_bias IS NOT NULL) AND (NEW.codon_bias IS NULL)) OR (OLD.codon_bias != NEW.codon_bias)) THEN
        PERFORM nex.insertupdatelog('PROTEINSEQUENCE_DETAIL'::text, 'CODON_BIAS'::text, OLD.detail_id, OLD.CODON_BIAS::text, NEW.codon_bias::text, USER);
    END IF;

    IF (((OLD.fop_score IS NULL) AND (NEW.fop_score IS NOT NULL)) OR ((OLD.fop_score IS NOT NULL) AND (NEW.fop_score IS NULL)) OR (OLD.fop_score != NEW.fop_score)) THEN
        PERFORM nex.insertupdatelog('PROTEINSEQUENCE_DETAIL'::text, 'FOP_SCORE'::text, OLD.detail_id, OLD.FOP_SCORE::text, NEW.fop_score::text, USER);
    END IF;

    IF (((OLD.gravy_score IS NULL) AND (NEW.gravy_score IS NOT NULL)) OR ((OLD.gravy_score IS NOT NULL) AND (NEW.gravy_score IS NULL)) OR (OLD.gravy_score != NEW.gravy_score)) THEN
        PERFORM nex.insertupdatelog('PROTEINSEQUENCE_DETAIL'::text, 'GRAVY_SCORE'::text, OLD.detail_id, OLD.GRAVY_SCORE::text, NEW.gravy_score::text, USER);
    END IF;

    IF (((OLD.aromaticity_score IS NULL) AND (NEW.aromaticity_score IS NOT NULL)) OR ((OLD.aromaticity_score IS NOT NULL) AND (NEW.aromaticity_score IS NULL)) OR (OLD.aromaticity_score != NEW.aromaticity_score)) THEN
        PERFORM nex.insertupdatelog('PROTEINSEQUENCE_DETAIL'::text, 'AROMATICITY_SCORE'::text, OLD.detail_id, OLD.AROMATICITY_SCORE::text, NEW.aromaticity_score::text, USER);
    END IF;

    IF (((OLD.aliphatic_index IS NULL) AND (NEW.aliphatic_index IS NOT NULL)) OR ((OLD.aliphatic_index IS NOT NULL) AND (NEW.aliphatic_index IS NULL)) OR (OLD.aliphatic_index != NEW.aliphatic_index)) THEN
        PERFORM nex.insertupdatelog('PROTEINSEQUENCE_DETAIL'::text, 'ALIPHATIC_INDEX'::text, OLD.detail_id, OLD.ALIPHATIC_INDEX::text, NEW.aliphatic_index::text, USER);
    END IF;

    IF (((OLD.instability_index IS NULL) AND (NEW.instability_index IS NOT NULL)) OR ((OLD.instability_index IS NOT NULL) AND (NEW.instability_index IS NULL)) OR (OLD.instability_index != NEW.instability_index)) THEN
        PERFORM nex.insertupdatelog('PROTEINSEQUENCE_DETAIL'::text, 'INSTABILITY_INDEX'::text, OLD.detail_id, OLD.INSTABILITY_INDEX::text, NEW.instability_index::text, USER);
    END IF;

    IF (OLD.ala != NEW.ala) THEN
        PERFORM nex.insertupdatelog('PROTEINSEQUENCE_DETAIL'::text, 'ALA'::text, OLD.detail_id, OLD.ALA::text, NEW.ala::text, USER);
    END IF;

    IF (OLD.arg != NEW.arg) THEN
        PERFORM nex.insertupdatelog('PROTEINSEQUENCE_DETAIL'::text, 'ARG'::text, OLD.detail_id, OLD.ARG::text, NEW.arg::text, USER);
    END IF;

    IF (OLD.asn != NEW.asn) THEN
        PERFORM nex.insertupdatelog('PROTEINSEQUENCE_DETAIL'::text, 'ASN'::text, OLD.detail_id, OLD.ASN::text, NEW.asn::text, USER);
    END IF;

    IF (OLD.asp != NEW.asp) THEN
        PERFORM nex.insertupdatelog('PROTEINSEQUENCE_DETAIL'::text, 'ASP'::text, OLD.detail_id, OLD.ASP::text, NEW.asp::text, USER);
    END IF;

    IF (OLD.cys != NEW.cys) THEN
        PERFORM nex.insertupdatelog('PROTEINSEQUENCE_DETAIL'::text, 'CYS'::text, OLD.detail_id, OLD.CYS::text, NEW.cys::text, USER);
    END IF;

    IF (OLD.gln != NEW.gln) THEN
        PERFORM nex.insertupdatelog('PROTEINSEQUENCE_DETAIL'::text, 'GLN'::text, OLD.detail_id, OLD.GLN::text, NEW.gln::text, USER);
    END IF;

    IF (OLD.glu != NEW.glu) THEN
        PERFORM nex.insertupdatelog('PROTEINSEQUENCE_DETAIL'::text, 'GLU'::text, OLD.detail_id, OLD.GLU::text, NEW.glu::text, USER);
    END IF;

    IF (OLD.gly != NEW.gly) THEN
        PERFORM nex.insertupdatelog('PROTEINSEQUENCE_DETAIL'::text, 'GLY'::text, OLD.detail_id, OLD.GLY::text, NEW.gly::text, USER);
    END IF;

    IF (OLD.his != NEW.his) THEN
        PERFORM nex.insertupdatelog('PROTEINSEQUENCE_DETAIL'::text, 'HIS'::text, OLD.detail_id, OLD.HIS::text, NEW.his::text, USER);
    END IF;

    IF (OLD.ile != NEW.ile) THEN
        PERFORM nex.insertupdatelog('PROTEINSEQUENCE_DETAIL'::text, 'ILE'::text, OLD.detail_id, OLD.ILE::text, NEW.ile::text, USER);
    END IF;

    IF (OLD.leu != NEW.leu) THEN
        PERFORM nex.insertupdatelog('PROTEINSEQUENCE_DETAIL'::text, 'LEU'::text, OLD.detail_id, OLD.LEU::text, NEW.leu::text, USER);
    END IF;

    IF (OLD.lys != NEW.lys) THEN
        PERFORM nex.insertupdatelog('PROTEINSEQUENCE_DETAIL'::text, 'LYS'::text, OLD.detail_id, OLD.LYS::text, NEW.lys::text, USER);
    END IF;

    IF (OLD.met != NEW.met) THEN
        PERFORM nex.insertupdatelog('PROTEINSEQUENCE_DETAIL'::text, 'MET'::text, OLD.detail_id, OLD.MET::text, NEW.met::text, USER);
    END IF;

    IF (OLD.phe != NEW.phe) THEN
        PERFORM nex.insertupdatelog('PROTEINSEQUENCE_DETAIL'::text, 'PHE'::text, OLD.detail_id, OLD.PHE::text, NEW.phe::text, USER);
    END IF;

    IF (OLD.pro != NEW.pro) THEN
        PERFORM nex.insertupdatelog('PROTEINSEQUENCE_DETAIL'::text, 'PRO'::text, OLD.detail_id, OLD.PRO::text, NEW.pro::text, USER);
    END IF;

    IF (OLD.ser != NEW.ser) THEN
        PERFORM nex.insertupdatelog('PROTEINSEQUENCE_DETAIL'::text, 'SER'::text, OLD.detail_id, OLD.SER::text, NEW.ser::text, USER);
    END IF;

    IF (OLD.thr != NEW.thr) THEN
        PERFORM nex.insertupdatelog('PROTEINSEQUENCE_DETAIL'::text, 'THR'::text, OLD.detail_id, OLD.THR::text, NEW.thr::text, USER);
    END IF;

    IF (OLD.trp != NEW.trp) THEN
        PERFORM nex.insertupdatelog('PROTEINSEQUENCE_DETAIL'::text, 'TRP'::text, OLD.detail_id, OLD.TRP::text, NEW.trp::text, USER);
    END IF;

    IF (OLD.tyr != NEW.tyr) THEN
        PERFORM nex.insertupdatelog('PROTEINSEQUENCE_DETAIL'::text, 'TYR'::text, OLD.detail_id, OLD.TYR::text, NEW.tyr::text, USER);
    END IF;

    IF (OLD.val != NEW.val) THEN
        PERFORM nex.insertupdatelog('PROTEINSEQUENCE_DETAIL'::text, 'VAL'::text, OLD.detail_id, OLD.VAL::text, NEW.val::text, USER);
    END IF;

    IF (((OLD.hydrogen IS NULL) AND (NEW.hydrogen IS NOT NULL)) OR ((OLD.hydrogen IS NOT NULL) AND (NEW.hydrogen IS NULL)) OR (OLD.hydrogen != NEW.hydrogen)) THEN
        PERFORM nex.insertupdatelog('PROTEINSEQUENCE_DETAIL'::text, 'HYDROGEN'::text, OLD.detail_id, OLD.HYDROGEN::text, NEW.hydrogen::text, USER);
    END IF;

    IF (((OLD.sulfur IS NULL) AND (NEW.sulfur IS NOT NULL)) OR ((OLD.sulfur IS NOT NULL) AND (NEW.sulfur IS NULL)) OR (OLD.sulfur != NEW.sulfur)) THEN
        PERFORM nex.insertupdatelog('PROTEINSEQUENCE_DETAIL'::text, 'SULFUR'::text, OLD.detail_id, OLD.SULFUR::text, NEW.sulfur::text, USER);
    END IF;

    IF (((OLD.nitrogen IS NULL) AND (NEW.nitrogen IS NOT NULL)) OR ((OLD.nitrogen IS NOT NULL) AND (NEW.nitrogen IS NULL)) OR (OLD.nitrogen != NEW.nitrogen)) THEN
       PERFORM nex.insertupdatelog('PROTEINSEQUENCE_DETAIL'::text, 'NITROGEN'::text, OLD.detail_id, OLD.NITROGEN::text, NEW.nitrogen::text, USER);
    END IF;

    IF (((OLD.oxygen IS NULL) AND (NEW.oxygen IS NOT NULL)) OR ((OLD.oxygen IS NOT NULL) AND (NEW.oxygen IS NULL)) OR (OLD.oxygen != NEW.oxygen)) THEN
       PERFORM nex.insertupdatelog('PROTEINSEQUENCE_DETAIL'::text, 'OXYGEN'::text, OLD.detail_id, OLD.OXYGEN::text, NEW.oxygen::text, USER);
    END IF;

    IF (((OLD.carbon IS NULL) AND (NEW.carbon IS NOT NULL)) OR ((OLD.carbon IS NOT NULL) AND (NEW.carbon IS NULL)) OR (OLD.carbon != NEW.carbon)) THEN
       PERFORM nex.insertupdatelog('PROTEINSEQUENCE_DETAIL'::text, 'CARBON'::text, OLD.detail_id, OLD.CARBON::text, NEW.carbon::text, USER);
    END IF;

    IF (((OLD.no_cys_ext_coeff IS NULL) AND (NEW.no_cys_ext_coeff IS NOT NULL)) OR ((OLD.no_cys_ext_coeff IS NOT NULL) AND (NEW.no_cys_ext_coeff IS NULL)) OR (OLD.no_cys_ext_coeff != NEW.no_cys_ext_coeff)) THEN
       PERFORM nex.insertupdatelog('PROTEINSEQUENCE_DETAIL'::text, 'NO_CYS_EXT_COEFF'::text, OLD.detail_id, OLD.NO_CYS_EXT_COEFF::text, NEW.no_cys_ext_coeff::text, USER);
    END IF;

    IF (((OLD.all_cys_ext_coeff IS NULL) AND (NEW.all_cys_ext_coeff IS NOT NULL)) OR ((OLD.all_cys_ext_coeff IS NOT NULL) AND (NEW.all_cys_ext_coeff IS NULL)) OR (OLD.all_cys_ext_coeff != NEW.all_cys_ext_coeff)) THEN
       PERFORM nex.insertupdatelog('PROTEINSEQUENCE_DETAIL'::text, 'ALL_CYS_EXT_COEFF'::text, OLD.detail_id, OLD.ALL_CYS_EXT_COEFF::text, NEW.all_cys_ext_coeff::text, USER);
    END IF;

    RETURN NEW;
    
  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.annotation_id || '[:]' || 
             OLD.molecular_weight || '[:]' || OLD.protein_length || '[:]' ||
             OLD.n_term_seq || '[:]' || OLD.c_term_seq || '[:]' ||
             coalesce(OLD.pi,0) || '[:]' || coalesce(OLD.cai,0) || '[:]' ||
             coalesce(OLD.codon_bias,0) || '[:]' || coalesce(OLD.fop_score,0) || '[:]' ||
             coalesce(OLD.gravy_score,0) || '[:]' || coalesce(OLD.aromaticity_score,0) || '[:]' ||
             coalesce(OLD.aliphatic_index,0) || '[:]' || coalesce(OLD.instability_index,0) || '[:]' ||
             OLD.ala || '[:]' || OLD.arg || '[:]' || OLD.asn || '[:]' ||
             OLD.asp || '[:]' || OLD.cys || '[:]' || OLD.gln || '[:]' ||
             OLD.glu || '[:]' || OLD.gly || '[:]' || OLD.his || '[:]' ||
             OLD.ile || '[:]' || OLD.leu || '[:]' || OLD.lys || '[:]' ||
             OLD.met || '[:]' || OLD.phe || '[:]' || OLD.pro || '[:]' ||
             OLD.ser || '[:]' || OLD.thr || '[:]' || OLD.trp || '[:]' ||
             OLD.tyr || '[:]' || OLD.val || '[:]' ||
             coalesce(OLD.hydrogen,0) || '[:]' || coalesce(OLD.sulfur,0) || '[:]' ||
             coalesce(OLD.nitrogen,0) || '[:]' || coalesce(OLD.oxygen,0) || '[:]' ||
             coalesce(OLD.cargon,0) || '[:]' || coalesce(OLD.no_cys_ext_coeff,0) || '[:]' ||
             coalesce(OLD.all_cys_ext_coeff,0) || '[:]' ||	     
             OLD.date_created || '[:]' || OLD.created_by;

           PERFORM nex.insertdeletelog('PROTEINSEQUENCE_DETAIL'::text, OLD.detail_id, v_row, USER);

      RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER proteinsequencedetail_audr
AFTER UPDATE OR DELETE ON nex.proteinsequence_detail FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_proteinsequencedetail_audr();

DROP TRIGGER IF EXISTS proteinsequencedetail_biur ON nex.proteinsequence_detail CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_proteinsequencedetail_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.detail_id != OLD.detail_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER proteinsequencedetail_biur
BEFORE INSERT OR UPDATE ON nex.proteinsequence_detail FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_proteinsequencedetail_biur();


DROP TRIGGER IF EXISTS regulationannotation_audr ON nex.regulationannotation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_regulationannotation_audr() RETURNS trigger AS $BODY$
DECLARE
    v_row       nex.deletelog.deleted_row%TYPE;
BEGIN
  IF (TG_OP = 'UPDATE') THEN

    IF (OLD.target_id != NEW.target_id) THEN
        PERFORM nex.insertupdatelog('REGULATIONANNOTATION'::text, 'TARGET_ID'::text, OLD.annotation_id, OLD.target_id::text, NEW.target_id::text, USER);
    END IF;

    IF (OLD.regulator_id != NEW.regulator_id) THEN
        PERFORM nex.insertupdatelog('REGULATIONANNOTATION'::text, 'REGULATOR_ID'::text, OLD.annotation_id, OLD.regulator_id::text, NEW.regulator_id::text, USER);
    END IF;

     IF (OLD.source_id != NEW.source_id) THEN
        PERFORM nex.insertupdatelog('REGULATIONANNOTATION'::text, 'SOURCE_ID'::text, OLD.annotation_id, OLD.source_id::text, NEW.source_id::text, USER);
    END IF;

    IF (OLD.taxonomy_id != NEW.taxonomy_id) THEN
        PERFORM nex.insertupdatelog('REGULATIONANNOTATION'::text, 'TAXONOMY_ID'::text, OLD.annotation_id, OLD.taxonomy_id::text, NEW.taxonomy_id::text, USER);
    END IF;

    IF  (OLD.reference_id != NEW.reference_id) THEN
        PERFORM nex.insertupdatelog('REGULATIONANNOTATION'::text, 'REFERENCE_ID'::text, OLD.annotation_id, OLD.reference_id::text, NEW.reference_id::text, USER);
    END IF;

    IF (OLD.eco_id != NEW.eco_id) THEN
        PERFORM nex.insertupdatelog('REGULATIONANNOTATION'::text, 'ECO_ID'::text, OLD.annotation_id, OLD.eco_id::text, NEW.eco_id::text, USER);
    END IF;

    IF (OLD.annotation_type != NEW.annotation_type) THEN
        PERFORM nex.insertupdatelog('REGULATIONANNOTATION'::text, 'ANNOTATION_TYPE'::text, OLD.annotation_id, OLD.annotation_type, NEW.annotation_type, USER);
    END IF;

    IF (OLD.regulator_type != NEW.regulator_type) THEN
        PERFORM nex.insertupdatelog('REGULATIONANNOTATION'::text, 'REGULATOR_TYPE'::text, OLD.annotation_id, OLD.regulator_type, NEW.regulator_type, USER);
    END IF;

    IF (OLD.regulation_type != NEW.regulation_type) THEN
        PERFORM nex.insertupdatelog('REGULATIONANNOTATION'::text, 'REGULATION_TYPE'::text, OLD.annotation_id, OLD.regulation_type, NEW.regulation_type, USER);
    END IF;

    IF (((OLD.direction IS NULL) AND (NEW.direction IS NOT NULL)) OR ((OLD.direction IS NOT NULL) AND (NEW.direction IS NULL)) OR (OLD.direction != NEW.direction)) THEN
        PERFORM nex.insertupdatelog('REGULATIONANNOTATION'::text, 'DIRECTION'::text, OLD.annotation_id, OLD.direction, NEW.direction, USER);
    END IF;

    IF (((OLD.happens_during IS NULL) AND (NEW.happens_during IS NOT NULL)) OR ((OLD.happens_during IS NOT NULL) AND (NEW.happens_during IS NULL)) OR (OLD.happens_during != NEW.happens_during)) THEN
        PERFORM nex.insertupdatelog('REGULATIONANNOTATION'::text, 'HAPPENS_DURING'::text, OLD.annotation_id, OLD.happens_during::text, NEW.happens_during::text, USER);
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN

    v_row := OLD.annotation_id || '[:]' || OLD.target_id || '[:]' ||
             OLD.regulator_id || '[:]' || OLD.source_id || '[:]' ||
             OLD.taxonomy_id || '[:]' || OLD.reference_id || '[:]' ||
             OLD.eco_id || '[:]' || OLD.annotation_type || '[:]' ||
             OLD.regulator_type || '[:]' || OLD.regulation_type || '[:]' || 
             coalesce(OLD.direction,'') || '[:]' || coalesce(OLD.happens_during,'') || '[:]' ||
             OLD.date_created || '[:]' || OLD.created_by;

          PERFORM nex.insertdeletelog('REGULATIONANNOTATION'::text, OLD.annotation_id, v_row, USER);

     RETURN OLD;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER regulationannotation_audr
AFTER UPDATE OR DELETE ON nex.regulationannotation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_regulationannotation_audr();

DROP TRIGGER IF EXISTS regulationannotation_biur ON nex.regulationannotation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_regulationannotation_biur() RETURNS trigger AS $BODY$
BEGIN
  IF (TG_OP = 'INSERT') THEN

       NEW.created_by := UPPER(NEW.created_by);
       PERFORM nex.checkuser(NEW.created_by);

       IF (NEW.direction is NOT NULL) THEN
          IF (NEW.direction != 'positive') THEN
             IF (NEW.direction != 'negative') THEN
                RAISE EXCEPTION 'Allowable values are positive, negative, or null.';
             END IF;
          END IF;
       END IF;

      IF ((NEW.regulator_type = 'transcription factor') OR (NEW.regulator_type = 'chromatin modifier')) THEN
         IF (NEW.regulation_type = 'protein activity') THEN
             RAISE EXCEPTION 'That regulation_type is not allowed with that regulator_type.';
         END IF;
      ELSIF (NEW.regulator_type = 'protein modifier') THEN
         IF (NEW.regulation_type = 'transcription') THEN
             RAISE EXCEPTION 'That regulation_type is not allowed with that regulator_type.';
         END IF;
      END IF;

       RETURN NEW;

  ELSIF (TG_OP = 'UPDATE') THEN

    IF (NEW.annotation_id != OLD.annotation_id) THEN
        RAISE EXCEPTION 'Primary key cannot be updated';
    END IF;

    IF (NEW.date_created != OLD.date_created) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

    IF (NEW.created_by != OLD.created_by) THEN
        RAISE EXCEPTION 'Audit columns cannot be updated.';
    END IF;

       IF (NEW.direction is NOT NULL) THEN
          IF (NEW.direction != 'positive') THEN
             IF (NEW.direction != 'negative') THEN
                RAISE EXCEPTION 'Allowable values are positive, negative, or null.';
             END IF;
          END IF;
       END IF;

      IF ((NEW.regulator_type = 'transcription factor') OR (NEW.regulator_type = 'chromatin modifier')) THEN
         IF (NEW.regulation_type = 'protein activity') THEN
             RAISE EXCEPTION 'That regulation_type is not allowed with that regulator_type.';
         END IF;
      ELSIF (NEW.regulator_type = 'protein modifier') THEN
         IF (NEW.regulation_type = 'transcription') THEN
             RAISE EXCEPTION 'That regulation_type is not allowed with that regulator_type.';
         END IF;
      END IF;

    RETURN NEW;
  END IF;

END;
$BODY$ LANGUAGE 'plpgsql';

CREATE TRIGGER regulationannotation_biur
BEFORE INSERT OR UPDATE ON nex.regulationannotation FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_regulationannotation_biur();
